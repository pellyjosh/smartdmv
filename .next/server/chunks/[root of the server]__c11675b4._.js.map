{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/db.config.ts"],"sourcesContent":["import * as pgCore from 'drizzle-orm/pg-core';\nimport * as sqliteCore from 'drizzle-orm/sqlite-core';\n\nconst dbType = process.env.DB_TYPE || 'postgres';\n\nexport const dbTable = (name: string, columns: any, config?: any) => {\n  if (dbType === 'sqlite') {\n    return sqliteCore.sqliteTable(name, columns, config);\n  }\n  return pgCore.pgTable(name, columns, config);\n};\n\nexport const text = (name: string, p0?: { enum: readonly [\"CLIENT\", \"PRACTICE_ADMINISTRATOR\", \"ADMINISTRATOR\"]; }) =>\n  dbType === 'sqlite' ? sqliteCore.text(name) : pgCore.text(name);\n\nexport const integer = (name: string) =>\n  dbType === 'sqlite' ? sqliteCore.integer() : pgCore.integer(name);\n\nexport const primaryKey = dbType === 'sqlite' ? sqliteCore.primaryKey : pgCore.primaryKey;\n\nexport const timestamp = (name: string, p0?: { mode: string; }) =>\n  dbType === 'sqlite' ? sqliteCore.integer() : pgCore.timestamp(name);"],"names":[],"mappings":";;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,OAAO,IAAI;AAE/B,MAAM,UAAU,CAAC,MAAc,SAAc;IAClD,IAAI,WAAW,UAAU;QACvB,OAAO,CAAA,GAAA,2JAAA,CAAA,cAAsB,AAAD,EAAE,MAAM,SAAS;IAC/C;IACA,OAAO,CAAA,GAAA,uJAAA,CAAA,UAAc,AAAD,EAAE,MAAM,SAAS;AACvC;AAEO,MAAM,OAAO,CAAC,MAAc,KACjC,WAAW,WAAW,CAAA,GAAA,qKAAA,CAAA,OAAe,AAAD,EAAE,QAAQ,CAAA,GAAA,iKAAA,CAAA,OAAW,AAAD,EAAE;AAErD,MAAM,UAAU,CAAC,OACtB,WAAW,WAAW,CAAA,GAAA,wKAAA,CAAA,UAAkB,AAAD,MAAM,CAAA,GAAA,oKAAA,CAAA,UAAc,AAAD,EAAE;AAEvD,MAAM,aAAa,WAAW,WAAW,qKAAA,CAAA,aAAqB,GAAG,iKAAA,CAAA,aAAiB;AAElF,MAAM,YAAY,CAAC,MAAc,KACtC,WAAW,WAAW,CAAA,GAAA,wKAAA,CAAA,UAAkB,AAAD,MAAM,CAAA,GAAA,sKAAA,CAAA,YAAgB,AAAD,EAAE","debugId":null}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schemas/practicesSchema.ts"],"sourcesContent":["import { dbTable, text, timestamp } from '@/db/db.config'; // Removed primaryKey as it's not used here\nimport { relations, sql } from 'drizzle-orm';\nimport { users } from './usersSchema';\nimport { administratorAccessiblePractices } from './usersSchema'; // Keep this if it's the join table\n\nconst isSqlite = process.env.DB_TYPE === 'sqlite';\n\nexport const practices = dbTable('practices', {\n  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),\n  name: text('name').notNull(),\n  createdAt: isSqlite\n    ? timestamp('createdAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`)\n    : timestamp('createdAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n\n  updatedAt: isSqlite\n    ? timestamp('updatedAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`).$onUpdate(() => sql`CURRENT_TIMESTAMP`)\n    : timestamp('updatedAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n});\n\nexport const practicesRelations = relations(practices, ({ many }) => ({\n  usersPractice: many(users, { relationName: 'usersPracticeRelation' }),\n  usersCurrentPractice: many(users, { relationName: 'usersCurrentPracticeRelation' }),\n  accessibleToAdmins: many(administratorAccessiblePractices),\n}));\n"],"names":[],"mappings":";;;;AAAA,qNAA2D,2CAA2C;AACtG;AAAA;AACA;;;;;AAGA,MAAM,WAAW,QAAQ,GAAG,CAAC,OAAO,KAAK;AAElC,MAAM,YAAY,CAAA,GAAA,2HAAA,CAAA,UAAO,AAAD,EAAE,aAAa;IAC5C,IAAI,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,OAAO,UAAU;IAC9D,MAAM,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE,QAAQ,OAAO;IAC1B,WAAW,WACP,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAe,GAAG,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,IACzF,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,EAAE,OAAO;IAEpF,WAAW,WACP,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAe,GAAG,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,EAAE,SAAS,CAAC,IAAM,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,IACjI,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,EAAE,OAAO;AACtF;AAEO,MAAM,qBAAqB,CAAA,GAAA,6IAAA,CAAA,YAAS,AAAD,EAAE,WAAW,CAAC,EAAE,IAAI,EAAE,GAAK,CAAC;QACpE,eAAe,KAAK,qIAAA,CAAA,QAAK,EAAE;YAAE,cAAc;QAAwB;QACnE,sBAAsB,KAAK,qIAAA,CAAA,QAAK,EAAE;YAAE,cAAc;QAA+B;QACjF,oBAAoB,KAAK,qIAAA,CAAA,mCAAgC;IAC3D,CAAC","debugId":null}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schemas/sessionsSchema.ts"],"sourcesContent":["// sessionsSchema.ts\nimport { dbTable, text, timestamp } from '@/db/db.config';\nimport { relations, sql } from 'drizzle-orm';\nimport { users } from './usersSchema';\n\nconst isSqlite = process.env.DB_TYPE === 'sqlite';\n\nexport const sessions = dbTable('sessions', {\n    id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID() as any),\n    userId: text('user_id').notNull().references(() => users.id as any, { onDelete: 'cascade' }),\n    \n    // For SQLite, timestamp (which is integer) can store Unix epoch seconds or milliseconds.\n    // For PG, timestamp with mode: 'date' and withTimezone: true is more appropriate.\n    expiresAt: isSqlite\n      ? timestamp('expiresAt', {mode: 'timestamp_ms'}).notNull() // Drizzle uses integer for SQLite timestamps\n      : timestamp('expiresAt').notNull(),\n\n    data: text('data'), // Assuming JSON stored as text\n    \n    createdAt: isSqlite\n      ? timestamp('createdAt', {mode: 'timestamp_ms'}).notNull().default(sql`CURRENT_TIMESTAMP`)\n      : timestamp('createdAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`)\n  });\n\nexport const sessionsRelations = relations(sessions, ({ one }) => ({\n    user: one(users, {\n      fields: [sessions.userId],\n      references: [users.id],\n    }),\n  }));\n"],"names":[],"mappings":"AAAA,oBAAoB;;;;;AACpB;AACA;AAAA;AACA;;;;AAEA,MAAM,WAAW,QAAQ,GAAG,CAAC,OAAO,KAAK;AAElC,MAAM,WAAW,CAAA,GAAA,2HAAA,CAAA,UAAO,AAAD,EAAE,YAAY;IACxC,IAAI,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,OAAO,UAAU;IAC9D,QAAQ,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE,WAAW,OAAO,GAAG,UAAU,CAAC,IAAM,qIAAA,CAAA,QAAK,CAAC,EAAE,EAAS;QAAE,UAAU;IAAU;IAE1F,yFAAyF;IACzF,kFAAkF;IAClF,WAAW,WACP,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAC,MAAM;IAAc,GAAG,OAAO,GAAG,6CAA6C;OACtG,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa,OAAO;IAElC,MAAM,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE;IAEX,WAAW,WACP,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAC,MAAM;IAAc,GAAG,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,IACvF,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAO,GAAG,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC;AACvF;AAEK,MAAM,oBAAoB,CAAA,GAAA,6IAAA,CAAA,YAAS,AAAD,EAAE,UAAU,CAAC,EAAE,GAAG,EAAE,GAAK,CAAC;QAC/D,MAAM,IAAI,qIAAA,CAAA,QAAK,EAAE;YACf,QAAQ;gBAAC,SAAS,MAAM;aAAC;YACzB,YAAY;gBAAC,qIAAA,CAAA,QAAK,CAAC,EAAE;aAAC;QACxB;IACF,CAAC","debugId":null}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schemas/usersSchema.ts"],"sourcesContent":["\n// schema/usersSchema.ts\nimport { dbTable, text, timestamp, primaryKey } from '@/db/db.config';\nimport { relations, sql } from 'drizzle-orm';\nimport { practices } from './practicesSchema';\nimport { sessions } from './sessionsSchema';\n\nconst isSqlite = process.env.DB_TYPE === 'sqlite';\n\nexport const userRoleEnum = ['CLIENT', 'PRACTICE_ADMINISTRATOR', 'ADMINISTRATOR'] as const;\n\nexport const users = dbTable('users', {\n  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),\n  email: text('email').notNull().unique(),\n  name: text('name'),\n  password: text('password').notNull(),\n  role: text('role', { enum: userRoleEnum }).notNull(),\n  practiceId: text('practice_id').references(() => practices.id as any, { onDelete: 'set null' }),\n  currentPracticeId: text('current_practice_id').references(() => practices.id as any, { onDelete: 'set null' }),\n\n  createdAt: isSqlite\n    ? timestamp('createdAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('createdAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n\n  updatedAt: isSqlite\n    ? timestamp('updatedAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`).$onUpdate(() => sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('updatedAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`).$onUpdateFn(() => new Date()),\n});\n\nexport const administratorAccessiblePractices = dbTable('administrator_accessible_practices', {\n  administratorId: text('administrator_id').notNull().references(() => users.id as any, { onDelete: 'cascade' }),\n  practiceId: text('practice_id').notNull().references(() => practices.id as any, { onDelete: 'cascade' }),\n\n  assignedAt: isSqlite\n    ? timestamp('assignedAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('assignedAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`),\n\n  createdAt: isSqlite\n    ? timestamp('createdAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('createdAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`),\n\n  updatedAt: isSqlite\n    ? timestamp('updatedAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`).$onUpdate(() => sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('updatedAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`).$onUpdateFn(() => new Date()),\n}, (table: { administratorId: any; practiceId: any; }) => ({\n  pk: primaryKey({ columns: [table.administratorId, table.practiceId] }),\n}));\n\nexport const usersRelations = relations(users, ({ one, many }) => ({\n  assignedPractice: one(practices, {\n    fields: [users.practiceId],\n    references: [practices.id],\n    relationName: 'usersPracticeRelation',\n  }),\n  currentSelectedPractice: one(practices, {\n    fields: [users.currentPracticeId],\n    references: [practices.id],\n    relationName: 'usersCurrentPracticeRelation',\n  }),\n  accessiblePractices: many(administratorAccessiblePractices),\n  sessions: many(sessions),\n}));\n\nexport const administratorAccessiblePracticesRelations = relations(administratorAccessiblePractices, ({ one }) => ({\n  administrator: one(users, {\n    fields: [administratorAccessiblePractices.administratorId],\n    references: [users.id],\n  }),\n  practice: one(practices, {\n    fields: [administratorAccessiblePractices.practiceId],\n    references: [practices.id],\n  }),\n}));\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schema.ts"],"sourcesContent":["import { users, administratorAccessiblePractices } from './schemas/usersSchema';\nimport { practices } from './schemas/practicesSchema';\nimport { sessions } from './schemas/sessionsSchema';\nexport const schema = {\n  users,\n  practices,\n  sessions,\n  administratorAccessiblePractices,\n};\n\n// Re-export all tables and their relations for Drizzle to use\nexport * from './schemas/practicesSchema';\nexport * from './schemas/sessionsSchema';\nexport * from './schemas/usersSchema';"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACO,MAAM,SAAS;IACpB,OAAA,qIAAA,CAAA,QAAK;IACL,WAAA,yIAAA,CAAA,YAAS;IACT,UAAA,wIAAA,CAAA,WAAQ;IACR,kCAAA,qIAAA,CAAA,mCAAgC;AAClC","debugId":null}},
    {"offset": {"line": 435, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/index.ts"],"sourcesContent":["\nimport { config } from 'dotenv';\nconfig(); // Load environment variables at the very top\n\n// index.ts\nimport { drizzle as drizzlePostgres } from 'drizzle-orm/node-postgres';\nimport { drizzle as drizzleSqlite } from 'drizzle-orm/better-sqlite3';\nimport { Pool } from 'pg';\nimport Database from 'better-sqlite3';\nimport * as schema from './schema';\n\n// âœ… Extend globalThis for custom caching variables\ndeclare global {\n  // biome-ignore lint/style/noVar: This is needed for global declarations\n  var DrizzlePostgresClient: Pool | undefined;\n  var DrizzleSqliteClient: ReturnType<typeof Database> | undefined;\n}\n\n// âœ… Ensure this file is treated as a module\nexport {};\n\nlet dbInstance: ReturnType<typeof drizzlePostgres> | ReturnType<typeof drizzleSqlite>;\n\nconst dbType = process.env.DB_TYPE || 'postgres'; // Default to PostgreSQL\nconsole.log(`[DB_INIT] DB_TYPE set to: ${dbType}`);\n\n\nif (dbType === 'postgres') {\n  if (!process.env.POSTGRES_URL) {\n    throw new Error('POSTGRES_URL environment variable is not set for DB_TYPE=\"postgres\".');\n  }\n\n  console.log('ðŸ”Œ Connecting to PostgreSQL database...');\n\n  let poolClient: Pool;\n  if (process.env.NODE_ENV === 'production') {\n    poolClient = new Pool({ connectionString: process.env.POSTGRES_URL });\n  } else {\n    if (!global.DrizzlePostgresClient) {\n      global.DrizzlePostgresClient = new Pool({ connectionString: process.env.POSTGRES_URL });\n      console.log('[DB_INIT] New PostgreSQL global client created for development.');\n    } else {\n      console.log('[DB_INIT] Reusing existing PostgreSQL global client for development.');\n    }\n    poolClient = global.DrizzlePostgresClient;\n  }\n\n  dbInstance = drizzlePostgres(poolClient, {\n    schema,\n    logger: process.env.NODE_ENV === 'development',\n  });\n  console.log('âœ… PostgreSQL Drizzle instance created.');\n\n} else if (dbType === 'sqlite') {\n  if (!process.env.SQLITE_DB_PATH) {\n    throw new Error('SQLITE_DB_PATH environment variable is not set for DB_TYPE=\"sqlite\".');\n  }\n\n  console.log(`ðŸ”Œ Connecting to SQLite database at: ${process.env.SQLITE_DB_PATH}`);\n\n  let sqliteClient: ReturnType<typeof Database>;\n\n  if (process.env.NODE_ENV === 'production') {\n    sqliteClient = new Database(process.env.SQLITE_DB_PATH);\n  } else {\n    if (!global.DrizzleSqliteClient) {\n      global.DrizzleSqliteClient = new Database(process.env.SQLITE_DB_PATH);\n      console.log('[DB_INIT] New SQLite global client created for development.');\n    } else {\n      console.log('[DB_INIT] Reusing existing SQLite global client for development.');\n    }\n    sqliteClient = global.DrizzleSqliteClient;\n  }\n\n  dbInstance = drizzleSqlite(sqliteClient, {\n    schema,\n    logger: process.env.NODE_ENV === 'development',\n  });\n  console.log('âœ… SQLite Drizzle instance created.');\n\n} else {\n  throw new Error(`Unsupported DB_TYPE: ${dbType}. Must be \"postgres\" or \"sqlite\".`);\n}\n\nexport const db = dbInstance;\n"],"names":[],"mappings":";;;AACA;AAGA,WAAW;AACX;AACA;AACA;AACA;AACA;AAAA;;;;;;;AAPA,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,KAAK,6CAA6C;;;;;;AAmBvD,IAAI;AAEJ,MAAM,SAAS,QAAQ,GAAG,CAAC,OAAO,IAAI,YAAY,wBAAwB;AAC1E,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,QAAQ;AAGjD,IAAI,WAAW,YAAY;IACzB,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAE;QAC7B,MAAM,IAAI,MAAM;IAClB;IAEA,QAAQ,GAAG,CAAC;IAEZ,IAAI;IACJ,uCAA2C;;IAE3C,OAAO;QACL,IAAI,CAAC,OAAO,qBAAqB,EAAE;YACjC,OAAO,qBAAqB,GAAG,IAAI,oGAAA,CAAA,OAAI,CAAC;gBAAE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;YAAC;YACrF,QAAQ,GAAG,CAAC;QACd,OAAO;YACL,QAAQ,GAAG,CAAC;QACd;QACA,aAAa,OAAO,qBAAqB;IAC3C;IAEA,aAAa,CAAA,GAAA,8JAAA,CAAA,UAAe,AAAD,EAAE,YAAY;QACvC,QAAA;QACA,QAAQ,oDAAyB;IACnC;IACA,QAAQ,GAAG,CAAC;AAEd,OAAO,IAAI,WAAW,UAAU;IAC9B,IAAI,CAAC,QAAQ,GAAG,CAAC,cAAc,EAAE;QAC/B,MAAM,IAAI,MAAM;IAClB;IAEA,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,QAAQ,GAAG,CAAC,cAAc,EAAE;IAEhF,IAAI;IAEJ,uCAA2C;;IAE3C,OAAO;QACL,IAAI,CAAC,OAAO,mBAAmB,EAAE;YAC/B,OAAO,mBAAmB,GAAG,IAAI,2HAAA,CAAA,UAAQ,CAAC,QAAQ,GAAG,CAAC,cAAc;YACpE,QAAQ,GAAG,CAAC;QACd,OAAO;YACL,QAAQ,GAAG,CAAC;QACd;QACA,eAAe,OAAO,mBAAmB;IAC3C;IAEA,aAAa,CAAA,GAAA,+JAAA,CAAA,UAAa,AAAD,EAAE,cAAc;QACvC,QAAA;QACA,QAAQ,oDAAyB;IACnC;IACA,QAAQ,GAAG,CAAC;AAEd,OAAO;IACL,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,OAAO,iCAAiC,CAAC;AACnF;AAEO,MAAM,KAAK","debugId":null}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/config/authConstants.ts"],"sourcesContent":["\nexport const SESSION_TOKEN_COOKIE_NAME = 'smartdvm-user-session'; // Client-readable cookie with user object\nexport const HTTP_ONLY_SESSION_TOKEN_COOKIE_NAME = 'session_token'; // Server-set HttpOnly cookie (session ID)\nexport const SESSION_MAX_AGE_SECONDS = 60 * 60 * 24 * 7; // 7 days in seconds\n"],"names":[],"mappings":";;;;;AACO,MAAM,4BAA4B,yBAAyB,0CAA0C;AACrG,MAAM,sCAAsC,iBAAiB,0CAA0C;AACvG,MAAM,0BAA0B,KAAK,KAAK,KAAK,GAAG,oBAAoB","debugId":null}},
    {"offset": {"line": 532, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/api/auth/login/route.ts"],"sourcesContent":["\n// src/app/api/auth/login/route.ts\nimport { NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport { db } from '@/db';\nimport { users as usersTable, sessions as sessionsTable, administratorAccessiblePractices as adminPracticesTable } from '@/db/schema';\nimport { eq } from 'drizzle-orm';\nimport bcrypt from 'bcryptjs';\nimport { cookies } from 'next/headers';\nimport type { User as AuthUser } from '@/hooks/useAuth'; \nimport { HTTP_ONLY_SESSION_TOKEN_COOKIE_NAME, SESSION_MAX_AGE_SECONDS } from '@/config/authConstants';\n\nconst SignInSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address.' }),\n  password: z.string().min(1, { message: 'Password is required.' }),\n});\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const validationResult = SignInSchema.safeParse(body);\n\n    if (!validationResult.success) {\n      return NextResponse.json({ error: validationResult.error.errors.map(e => e.message).join(', ') }, { status: 400 });\n    }\n\n    const { email, password: inputPassword } = validationResult.data;\n\n    const userRecord = await db.query.users.findFirst({\n      where: eq(usersTable.email, email),\n    });\n\n    if (!userRecord || !userRecord.password) {\n      return NextResponse.json({ error: 'Invalid email or password.' }, { status: 401 });\n    }\n\n    const isPasswordValid = await bcrypt.compare(inputPassword, userRecord.password);\n\n    if (!isPasswordValid) {\n      return NextResponse.json({ error: 'Invalid email or password.' }, { status: 401 });\n    }\n\n    // Construct the full user object based on role\n    let userData: AuthUser;\n\n    if (userRecord.role === 'ADMINISTRATOR') {\n      const adminPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n        .from(adminPracticesTable)\n        .where(eq(adminPracticesTable.administratorId, userRecord.id));\n      \n      const accessiblePracticeIds = adminPractices.map(p => p.practiceId);\n      let currentPracticeId = userRecord.currentPracticeId;\n\n      if (!currentPracticeId && accessiblePracticeIds.length > 0) {\n        currentPracticeId = accessiblePracticeIds[0];\n      } else if (!currentPracticeId && accessiblePracticeIds.length === 0) {\n        console.warn(`[API Login] Administrator ${userRecord.email} has no current or accessible practices configured.`);\n        currentPracticeId = 'practice_NONE'; \n      }\n\n      userData = {\n        id: userRecord.id,\n        email: userRecord.email,\n        name: userRecord.name || undefined,\n        role: 'ADMINISTRATOR',\n        accessiblePracticeIds,\n        currentPracticeId: currentPracticeId!,\n      };\n    } else if (userRecord.role === 'PRACTICE_ADMINISTRATOR') {\n      if (!userRecord.practiceId) {\n        return NextResponse.json({ error: 'Practice Administrator is not associated with a practice.' }, { status: 500 });\n      }\n      userData = {\n        id: userRecord.id,\n        email: userRecord.email,\n        name: userRecord.name || undefined,\n        role: 'PRACTICE_ADMINISTRATOR',\n        practiceId: userRecord.practiceId,\n      };\n    } else if (userRecord.role === 'CLIENT') {\n      if (!userRecord.practiceId) {\n        return NextResponse.json({ error: 'Client is not associated with a practice.' }, { status: 500 });\n      }\n      userData = {\n        id: userRecord.id,\n        email: userRecord.email,\n        name: userRecord.name || undefined,\n        role: 'CLIENT',\n        practiceId: userRecord.practiceId,\n      };\n    } else {\n      return NextResponse.json({ error: 'Unknown user role.' }, { status: 500 });\n    }\n\n    // Session management\n    const sessionTokenValue = crypto.randomUUID(); // This is the session ID for DB\n    const sessionExpiresAtDate = new Date(Date.now() + SESSION_MAX_AGE_SECONDS * 1000); \n    const isSqlite = process.env.DB_TYPE === 'sqlite';\n\n    await db.insert(sessionsTable).values({\n      id: sessionTokenValue,\n      userId: userRecord.id,\n      expiresAt: isSqlite ? sessionExpiresAtDate.getTime() : sessionExpiresAtDate,\n      // data: null, // 'data' column can be used to store additional session info if needed\n      // createdAt will be handled by DB default\n    });\n\n    (await cookies()).set(HTTP_ONLY_SESSION_TOKEN_COOKIE_NAME, sessionTokenValue, { \n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      maxAge: SESSION_MAX_AGE_SECONDS, \n      path: '/',\n      sameSite: 'lax',\n      expires: sessionExpiresAtDate, \n    });\n\n    // Return the full user object to the client\n    return NextResponse.json({ user: userData, message: 'Signed in successfully!' });\n\n  } catch (error) {\n    console.error('API login error:', error); \n    return NextResponse.json({ error: 'An unexpected error occurred. Please try again.' }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}