{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/authActions.ts"],"sourcesContent":["\n'use server';\n\nimport { db } from '@/db';\nimport { users as usersTable, administratorAccessiblePractices as adminPracticesTable } from '@/db/schema';\nimport { eq } from 'drizzle-orm';\nimport bcrypt from 'bcryptjs';\nimport type { User, AdministratorUser } from '@/context/UserContext'; // Use User types from UserContext\n\nexport async function loginUserAction(emailInput: string, passwordInput: string): Promise<User> {\n  const result = await db.select().from(usersTable).where(eq(usersTable.email, emailInput)).limit(1);\n  const dbUser = result[0];\n\n  if (!dbUser || !dbUser.password) {\n    throw new Error('User not found or password not set.');\n  }\n\n  const passwordMatch = bcrypt.compareSync(passwordInput, dbUser.password);\n  if (!passwordMatch) {\n    throw new Error('Invalid credentials. Please try again.');\n  }\n\n  let userData: User;\n\n  if (dbUser.role === 'ADMINISTRATOR') {\n    const adminPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n      .from(adminPracticesTable)\n      .where(eq(adminPracticesTable.administratorId, dbUser.id));\n    \n    const accessiblePracticeIds = adminPractices.map(p => p.practiceId);\n    let currentPracticeId = dbUser.currentPracticeId;\n\n    if (!currentPracticeId && accessiblePracticeIds.length > 0) {\n      currentPracticeId = accessiblePracticeIds[0];\n    } else if (!currentPracticeId && accessiblePracticeIds.length === 0) {\n      console.warn(`Administrator ${dbUser.email} has no current or accessible practices configured.`);\n      currentPracticeId = 'practice_NONE'; // Fallback\n    }\n\n    userData = {\n      id: dbUser.id,\n      email: dbUser.email,\n      name: dbUser.name || undefined,\n      role: 'ADMINISTRATOR',\n      accessiblePracticeIds,\n      currentPracticeId: currentPracticeId!,\n    };\n  } else if (dbUser.role === 'PRACTICE_ADMINISTRATOR') {\n    if (!dbUser.practiceId) {\n      throw new Error('Practice Administrator is not associated with a practice.');\n    }\n    userData = {\n      id: dbUser.id,\n      email: dbUser.email,\n      name: dbUser.name || undefined,\n      role: 'PRACTICE_ADMINISTRATOR',\n      practiceId: dbUser.practiceId,\n    };\n  } else if (dbUser.role === 'CLIENT') {\n    if (!dbUser.practiceId) {\n      throw new Error('Client is not associated with a practice.');\n    }\n    userData = {\n      id: dbUser.id,\n      email: dbUser.email,\n      name: dbUser.name || undefined,\n      role: 'CLIENT',\n      practiceId: dbUser.practiceId,\n    };\n  } else {\n    throw new Error('Unknown user role.');\n  }\n  return userData;\n}\n\nexport async function switchPracticeAction(userId: string, newPracticeId: string): Promise<{ success: boolean; updatedUser?: User }> {\n  try {\n    // First, verify the user exists and is an administrator\n    const userResult = await db.select({ role: usersTable.role }).from(usersTable).where(eq(usersTable.id, userId)).limit(1);\n    if (!userResult[0] || userResult[0].role !== 'ADMINISTRATOR') {\n      throw new Error(\"User not found or not an administrator.\");\n    }\n\n    // We should also verify if newPracticeId is one of the admin's accessiblePracticeIds\n    // For now, proceeding with update. A full implementation would fetch accessible IDs again here or ensure client provides valid one.\n    const adminUserPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n      .from(adminPracticesTable)\n      .where(eq(adminPracticesTable.administratorId, userId));\n    if (!adminUserPractices.map(p => p.practiceId).includes(newPracticeId)) {\n        throw new Error(\"Administrator does not have access to this practice.\");\n    }\n\n\n    await db.update(usersTable)\n      .set({ currentPracticeId: newPracticeId })\n      .where(eq(usersTable.id, userId));\n    \n     const updatedDbUser = await db.select().from(usersTable).where(eq(usersTable.id, userId)).limit(1);\n     if(!updatedDbUser[0]) {\n        throw new Error(\"Failed to refetch user after update.\")\n     }\n    const adminPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n      .from(adminPracticesTable)\n      .where(eq(adminPracticesTable.administratorId, updatedDbUser[0].id));\n    const accessiblePracticeIds = adminPractices.map(p => p.practiceId);\n\n\n    const refreshedUser: AdministratorUser = { // Be specific with type\n        id: updatedDbUser[0].id,\n        email: updatedDbUser[0].email,\n        name: updatedDbUser[0].name || undefined,\n        role: 'ADMINISTRATOR',\n        accessiblePracticeIds: accessiblePracticeIds,\n        currentPracticeId: newPracticeId,\n    }\n\n    return { success: true, updatedUser: refreshedUser };\n  } catch (error) {\n    console.error(\"Failed to switch practice:\", error);\n    if (error instanceof Error) {\n        return { success: false, updatedUser: undefined }; // Consider returning error message\n    }\n    return { success: false };\n  }\n}\n"],"names":[],"mappings":";;;;;;IASsB;IAkEA","debugId":null}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/config/authConstants.ts"],"sourcesContent":["\nexport const SESSION_TOKEN_COOKIE_NAME = 'smartdvm-user-session'; // Client-readable cookie with user object\nexport const HTTP_ONLY_SESSION_TOKEN_COOKIE_NAME = 'session_token'; // Server-set HttpOnly cookie (session ID)\nexport const SESSION_MAX_AGE_SECONDS = 60 * 60 * 24 * 7; // 7 days in seconds\n"],"names":[],"mappings":";;;;;AACO,MAAM,4BAA4B,yBAAyB,0CAA0C;AACrG,MAAM,sCAAsC,iBAAiB,0CAA0C;AACvG,MAAM,0BAA0B,KAAK,KAAK,KAAK,GAAG,oBAAoB","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/context/UserContext.tsx"],"sourcesContent":["\n'use client';\n\nimport type { Dispatch, ReactNode, SetStateAction } from 'react';\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport { useRouter, usePathname } from 'next/navigation';\nimport { switchPracticeAction } from '@/actions/authActions';\nimport { SESSION_TOKEN_COOKIE_NAME, HTTP_ONLY_SESSION_TOKEN_COOKIE_NAME, SESSION_MAX_AGE_SECONDS } from '@/config/authConstants';\n\n// Define User types\nexport interface BaseUser {\n  id: string; // Added ID here\n  email: string;\n  name?: string;\n}\n\nexport interface ClientUser extends BaseUser {\n  role: 'CLIENT';\n  practiceId: string;\n}\n\nexport interface PracticeAdminUser extends BaseUser {\n  role: 'PRACTICE_ADMINISTRATOR';\n  practiceId: string;\n}\n\nexport interface AdministratorUser extends BaseUser {\n  role: 'ADMINISTRATOR';\n  accessiblePracticeIds: string[];\n  currentPracticeId: string;\n}\n\nexport type User = ClientUser | PracticeAdminUser | AdministratorUser;\n\nconst AUTH_PAGE = '/auth/login';\n\nconst PROTECTED_PATHS_CONFIG: Record<User['role'], string[]> = {\n  CLIENT: ['/client', '/favorites', '/symptom-checker'],\n  ADMINISTRATOR: ['/administrator' /* Add other admin specific routes */],\n  PRACTICE_ADMINISTRATOR: ['/practice-administrator' /* Add other practice-admin specific routes */],\n};\n\nfunction isPathProtectedForRole(pathname: string, role: User['role']): boolean {\n  const commonProtectedPaths = ['/settings']; // Example of a path accessible by multiple authenticated roles\n  const roleSpecificPaths = PROTECTED_PATHS_CONFIG[role] || [];\n  return [...roleSpecificPaths, ...commonProtectedPaths].some(protectedPath => pathname.startsWith(protectedPath));\n}\n\nfunction isGenerallyProtectedPath(pathname: string): boolean {\n    const allProtectedPaths = Object.values(PROTECTED_PATHS_CONFIG).flat();\n    // Add any paths that are protected regardless of role but require auth\n    const generalProtected = ['/favorites', '/symptom-checker', '/settings']; \n    return [...new Set([...allProtectedPaths, ...generalProtected])].some(p => pathname.startsWith(p));\n}\n\n\ninterface UserContextType {\n  user: User | null;\n  isLoading: boolean;\n  initialAuthChecked: boolean; // Renamed for clarity\n  login: (emailInput: string, passwordInput: string) => Promise<User | null>;\n  logout: () => Promise<void>;\n  switchPractice?: (newPracticeId: string) => Promise<void>;\n  fetchUser: () => Promise<void>; // Expose fetchUser if needed externally\n}\n\nconst UserContext = createContext<UserContextType | undefined>(undefined);\n\nconst setClientCookie = (name: string, value: string | null, days: number = SESSION_MAX_AGE_SECONDS / (24 * 60 * 60)) => {\n  if (typeof document === 'undefined') return;\n  let expires = \"\";\n  if (value) {\n    const date = new Date();\n    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n    expires = \"; expires=\" + date.toUTCString();\n  } else {\n    // To delete a cookie, set its Max-Age to 0 or a past date\n    expires = \"; Max-Age=0\";\n  }\n  document.cookie = name + \"=\" + (value || \"\") + expires + \"; path=/; SameSite=Lax\";\n  console.log(`[UserContext setClientCookie] Cookie ${name} set/deleted. Value:`, value ? '******' : null);\n};\n\n\nexport function UserProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [initialAuthChecked, setInitialAuthChecked] = useState(false);\n  const router = useRouter();\n  const pathname = usePathname();\n\n  const fetchUser = useCallback(async () => {\n    console.log('[UserContext fetchUser START] Attempting to fetch current user from /api/auth/me');\n    // No need to set isLoading true here if it's already true by default or set by caller\n    try {\n      console.log('[UserContext fetchUser] Calling fetch(\"/api/auth/me\")...');\n      const response = await fetch('/api/auth/me');\n      console.log('[UserContext fetchUser] fetch(\"/api/auth/me\") response status:', response.status);\n\n      if (response.ok) {\n        const userData: User | null = await response.json();\n        if (userData && userData.id) {\n          setUser(userData);\n          sessionStorage.setItem(SESSION_TOKEN_COOKIE_NAME, JSON.stringify(userData));\n          setClientCookie(SESSION_TOKEN_COOKIE_NAME, JSON.stringify(userData));\n          console.log('[UserContext fetchUser SUCCESS] User fetched and set:', userData.email, userData.role);\n        } else {\n          setUser(null);\n          sessionStorage.removeItem(SESSION_TOKEN_COOKIE_NAME);\n          setClientCookie(SESSION_TOKEN_COOKIE_NAME, null);\n          console.log('[UserContext fetchUser NO_USER] /api/auth/me returned no user or invalid data.');\n        }\n      } else {\n        setUser(null);\n        sessionStorage.removeItem(SESSION_TOKEN_COOKIE_NAME);\n        setClientCookie(SESSION_TOKEN_COOKIE_NAME, null);\n        console.warn(`[UserContext fetchUser API_FAIL] /api/auth/me call failed, status: ${response.status}`);\n      }\n    } catch (error) {\n      console.error('[UserContext fetchUser CATCH_ERROR] Error fetching current user:', error);\n      setUser(null);\n      sessionStorage.removeItem(SESSION_TOKEN_COOKIE_NAME);\n      setClientCookie(SESSION_TOKEN_COOKIE_NAME, null);\n    } finally {\n      setIsLoading(false);\n      setInitialAuthChecked(true);\n      console.log('[UserContext fetchUser FINALLY] fetchUser finished. isLoading:', false, 'initialAuthChecked:', true);\n    }\n  }, []);\n\n  useEffect(() => {\n    console.log('[UserContext Mount/Effect] Initializing user state.');\n    fetchUser();\n  }, [fetchUser]);\n\n  const navigateBasedOnRole = useCallback((role: User['role']) => {\n    console.log(`[UserContext Nav] Navigating based on role: ${role}`);\n    let targetPath = '/';\n    switch (role) {\n      case 'CLIENT':\n        targetPath = '/client';\n        break;\n      case 'ADMINISTRATOR':\n        targetPath = '/administrator';\n        break;\n      case 'PRACTICE_ADMINISTRATOR':\n        targetPath = '/practice-administrator';\n        break;\n      default:\n        console.warn(`[UserContext Nav] Unknown role for navigation: ${role}`);\n        targetPath = '/';\n    }\n    if (pathname !== targetPath) {\n      console.log(`[UserContext Nav Effect EXECUTE] Calling router.replace(${targetPath})`);\n      router.replace(targetPath);\n    } else {\n      console.log(`[UserContext Nav] Already on target path: ${targetPath}`);\n    }\n  }, [router, pathname]);\n\n  useEffect(() => {\n    console.log('[UserContext Nav Effect Check] user:', user ? user.email : null, 'initialAuthChecked:', initialAuthChecked, 'pathname:', pathname, 'isLoading:', isLoading);\n    if (!isLoading && initialAuthChecked) {\n      if (user && pathname === AUTH_PAGE) {\n        console.log('[UserContext Nav Effect EXECUTE from Login] User authenticated and on login page. Redirecting. Role:', user.role);\n        navigateBasedOnRole(user.role);\n      } else if (!user && pathname !== AUTH_PAGE && isGenerallyProtectedPath(pathname)) {\n        console.log(`[UserContext Nav Effect EXECUTE to Login] User not authenticated but on a protected page (${pathname}). Redirecting to login.`);\n        router.push(AUTH_PAGE);\n      }\n    } else {\n      console.log('[UserContext Nav Effect] Conditions for navigation not met (still loading/checking or path is public).');\n    }\n  }, [user, initialAuthChecked, pathname, isLoading, navigateBasedOnRole, router]);\n\n\n  const login = async (emailInput: string, passwordInput: string): Promise<User | null> => {\n    console.log('[UserContext login] Attempting login for:', emailInput);\n    setIsLoading(true);\n    try {\n      const response = await fetch('/api/auth/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email: emailInput, password: passwordInput }),\n      });\n      const data = await response.json();\n\n      if (!response.ok) {\n        console.error('[UserContext login] API login failed:', data.error || response.statusText);\n        setUser(null);\n        sessionStorage.removeItem(SESSION_TOKEN_COOKIE_NAME);\n        setClientCookie(SESSION_TOKEN_COOKIE_NAME, null);\n        throw new Error(data.error || `API Error: ${response.status}`);\n      }\n      \n      const loggedInUser = data.user as User;\n      if (loggedInUser && loggedInUser.id) {\n        setUser(loggedInUser);\n        sessionStorage.setItem(SESSION_TOKEN_COOKIE_NAME, JSON.stringify(loggedInUser));\n        setClientCookie(SESSION_TOKEN_COOKIE_NAME, JSON.stringify(loggedInUser));\n        console.log('[UserContext login SUCCESS] Login successful, user set in context:', loggedInUser.email, loggedInUser.role);\n        // Navigation is handled by the useEffect watching `user` state\n        return loggedInUser;\n      }\n      console.warn('[UserContext login] API returned ok, but no valid user data.');\n      setUser(null);\n      sessionStorage.removeItem(SESSION_TOKEN_COOKIE_NAME);\n      setClientCookie(SESSION_TOKEN_COOKIE_NAME, null);\n      return null;\n    } catch (error) {\n      console.error(\"[UserContext login CATCH_ERROR] Login error:\", error);\n      setUser(null); \n      sessionStorage.removeItem(SESSION_TOKEN_COOKIE_NAME);\n      setClientCookie(SESSION_TOKEN_COOKIE_NAME, null);\n      throw error; \n    } finally {\n      setIsLoading(false);\n      setInitialAuthChecked(true); \n      console.log('[UserContext login FINALLY] isLoading: false, initialAuthChecked: true');\n    }\n  };\n\n  const logout = async () => {\n    console.log('[UserContext logout] Attempting logout.');\n    setIsLoading(true);\n    try {\n      await fetch('/api/auth/logout', { method: 'POST' });\n      console.log('[UserContext logout] API logout call successful.');\n    } catch (err) {\n      console.error('[UserContext logout CATCH_ERROR] Error calling API to invalidate server session:', err);\n    } finally {\n      setUser(null);\n      sessionStorage.removeItem(SESSION_TOKEN_COOKIE_NAME);\n      setClientCookie(SESSION_TOKEN_COOKIE_NAME, null); // Clear client-side cookie\n      setClientCookie(HTTP_ONLY_SESSION_TOKEN_COOKIE_NAME, null); // Attempt to clear httpOnly cookie (browser might block this)\n      setIsLoading(false);\n      setInitialAuthChecked(true); \n      console.log('[UserContext logout FINALLY] Client state cleared. isLoading: false, initialAuthChecked: true. Redirecting to login.');\n      if (pathname !== AUTH_PAGE) {\n        router.push(AUTH_PAGE);\n      }\n    }\n  };\n\n const switchPractice = async (newPracticeId: string) => {\n    if (user && user.role === 'ADMINISTRATOR') {\n      console.log(`[UserContext switchPractice] Admin ${user.email} attempting to switch to practice ${newPracticeId}`);\n      setIsLoading(true);\n      try {\n        const { success, updatedUser } = await switchPracticeAction(user.id, newPracticeId);\n        if (success && updatedUser) {\n          setUser(updatedUser); \n          sessionStorage.setItem(SESSION_TOKEN_COOKIE_NAME, JSON.stringify(updatedUser));\n          setClientCookie(SESSION_TOKEN_COOKIE_NAME, JSON.stringify(updatedUser));\n          console.log('[UserContext switchPractice SUCCESS] Practice switched. New currentPracticeId:', updatedUser.currentPracticeId);\n        } else {\n          console.error(\"[UserContext switchPractice FAIL] Failed to switch practice via server action. Refetching user.\");\n           await fetchUser();\n        }\n      } catch (error) {\n        console.error(\"[UserContext switchPractice CATCH_ERROR] Error switching practice:\", error);\n        await fetchUser(); \n      } finally {\n        setIsLoading(false);\n        console.log('[UserContext switchPractice FINALLY] isLoading set to false.');\n      }\n    } else {\n      console.warn(\"[UserContext switchPractice] Switch practice called by non-admin or no user.\")\n    }\n  };\n\n  // Render children only after initial auth check is complete to avoid flashes or premature rendering\n  if (!initialAuthChecked && isLoading) {\n     // You could return a global loading spinner here for the whole app if desired\n     // For now, returning null means descendant Client Components might show their own loaders\n    return null; \n  }\n\n  return (\n    <UserContext.Provider value={{ user, isLoading, initialAuthChecked, login, logout, switchPractice, fetchUser }}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\nexport function useUser() {\n  const context = useContext(UserContext);\n  if (context === undefined) {\n    throw new Error('useUser must be used within a UserProvider');\n  }\n  return context;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 366, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n\nexport function hexToHslParts(hex: string): string | null {\n  if (!hex) return null;\n  let r = 0, g = 0, b = 0;\n  if (hex.length === 4) { // #RGB\n    r = parseInt(hex[1] + hex[1], 16);\n    g = parseInt(hex[2] + hex[2], 16);\n    b = parseInt(hex[3] + hex[3], 16);\n  } else if (hex.length === 7) { // #RRGGBB\n    r = parseInt(hex.substring(1, 3), 16);\n    g = parseInt(hex.substring(3, 5), 16);\n    b = parseInt(hex.substring(5, 7), 16);\n  } else {\n    return null; // Invalid hex format\n  }\n\n  r /= 255; g /= 255; b /= 255;\n  const max = Math.max(r, g, b), min = Math.min(r, g, b);\n  let h = 0, s = 0; // Default h, s to 0 for achromatic colors\n  const l = (max + min) / 2;\n\n  if (max !== min) {\n    const d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n      case g: h = (b - r) / d + 2; break;\n      case b: h = (r - g) / d + 4; break;\n    }\n    h /= 6;\n  }\n\n  const H = Math.round(h * 360);\n  const S = Math.round(s * 100);\n  const L = Math.round(l * 100);\n\n  return `${H} ${S}% ${L}%`;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,qIAAA,CAAA,OAAI,AAAD,EAAE;AACtB;AAEO,SAAS,cAAc,GAAW;IACvC,IAAI,CAAC,KAAK,OAAO;IACjB,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI;IACtB,IAAI,IAAI,MAAM,KAAK,GAAG;QACpB,IAAI,SAAS,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,EAAE;QAC9B,IAAI,SAAS,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,EAAE;QAC9B,IAAI,SAAS,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,EAAE;IAChC,OAAO,IAAI,IAAI,MAAM,KAAK,GAAG;QAC3B,IAAI,SAAS,IAAI,SAAS,CAAC,GAAG,IAAI;QAClC,IAAI,SAAS,IAAI,SAAS,CAAC,GAAG,IAAI;QAClC,IAAI,SAAS,IAAI,SAAS,CAAC,GAAG,IAAI;IACpC,OAAO;QACL,OAAO,MAAM,qBAAqB;IACpC;IAEA,KAAK;IAAK,KAAK;IAAK,KAAK;IACzB,MAAM,MAAM,KAAK,GAAG,CAAC,GAAG,GAAG,IAAI,MAAM,KAAK,GAAG,CAAC,GAAG,GAAG;IACpD,IAAI,IAAI,GAAG,IAAI,GAAG,0CAA0C;IAC5D,MAAM,IAAI,CAAC,MAAM,GAAG,IAAI;IAExB,IAAI,QAAQ,KAAK;QACf,MAAM,IAAI,MAAM;QAChB,IAAI,IAAI,MAAM,IAAI,CAAC,IAAI,MAAM,GAAG,IAAI,IAAI,CAAC,MAAM,GAAG;QAClD,OAAQ;YACN,KAAK;gBAAG,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC;gBAAG;YAC3C,KAAK;gBAAG,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;gBAAG;YAC7B,KAAK;gBAAG,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;gBAAG;QAC/B;QACA,KAAK;IACP;IAEA,MAAM,IAAI,KAAK,KAAK,CAAC,IAAI;IACzB,MAAM,IAAI,KAAK,KAAK,CAAC,IAAI;IACzB,MAAM,IAAI,KAAK,KAAK,CAAC,IAAI;IAEzB,OAAO,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AAC3B","debugId":null}},
    {"offset": {"line": 424, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/context/ThemeContext.tsx"],"sourcesContent":["\n\"use client\";\n\nimport type { Dispatch, ReactNode, SetStateAction } from 'react';\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport { hexToHslParts } from '@/lib/utils';\n\ntype Theme = 'light' | 'dark';\n\ninterface ThemeContextProps {\n  theme: Theme;\n  setTheme: Dispatch<SetStateAction<Theme>>;\n  primaryColor: string; // Stored as HEX\n  setPrimaryColor: Dispatch<SetStateAction<string>>;\n  isThemeMounted: boolean; // Expose mount status\n}\n\nconst ThemeContext = createContext<ThemeContextProps | undefined>(undefined);\n\nconst DEFAULT_PRIMARY_COLOR_HEX = '#009eed';\n\nexport function ThemeProvider({ children }: { children: ReactNode }) {\n  const [theme, setTheme] = useState<Theme>('light');\n  const [primaryColor, setPrimaryColor] = useState<string>(DEFAULT_PRIMARY_COLOR_HEX);\n  const [isThemeMounted, setIsThemeMounted] = useState(false); // Renamed for clarity\n\n  useEffect(() => {\n    const storedTheme = localStorage.getItem('vetconnectpro-theme') as Theme | null;\n    const storedPrimaryColor = localStorage.getItem('vetconnectpro-primary-color');\n\n    if (storedTheme) {\n      setTheme(storedTheme);\n    } else {\n      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n      setTheme(prefersDark ? 'dark' : 'light');\n    }\n\n    if (storedPrimaryColor) {\n      setPrimaryColor(storedPrimaryColor);\n    }\n    setIsThemeMounted(true); // Set mounted to true after initial load\n  }, []);\n\n  useEffect(() => {\n    if (!isThemeMounted) return;\n\n    document.documentElement.classList.remove('light', 'dark');\n    document.documentElement.classList.add(theme);\n    localStorage.setItem('vetconnectpro-theme', theme);\n  }, [theme, isThemeMounted]);\n\n  useEffect(() => {\n    if (!isThemeMounted) return;\n    \n    const primaryHslParts = hexToHslParts(primaryColor);\n    if (primaryHslParts) {\n      document.documentElement.style.setProperty('--primary', primaryHslParts);\n      document.documentElement.style.setProperty('--ring', primaryHslParts);\n      document.documentElement.style.setProperty('--sidebar-primary', primaryHslParts);\n      document.documentElement.style.setProperty('--sidebar-ring', primaryHslParts);\n    }\n    localStorage.setItem('vetconnectpro-primary-color', primaryColor);\n  }, [primaryColor, isThemeMounted]);\n\n  // Do not return null here; let ClientOnlyWrapper handle delayed rendering.\n  // The ThemeProvider needs to be in the tree for context to be available.\n  return (\n    <ThemeContext.Provider value={{ theme, setTheme, primaryColor, setPrimaryColor, isThemeMounted }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nexport function useTheme() {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;AAIA;AACA;AAJA;;;;AAgBA,MAAM,6BAAe,CAAA,GAAA,qMAAA,CAAA,gBAAa,AAAD,EAAiC;AAElE,MAAM,4BAA4B;AAE3B,SAAS,cAAc,EAAE,QAAQ,EAA2B;IACjE,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAS;IAC1C,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAU;IACzD,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,sBAAsB;IAEnF,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,MAAM,cAAc,aAAa,OAAO,CAAC;QACzC,MAAM,qBAAqB,aAAa,OAAO,CAAC;QAEhD,IAAI,aAAa;YACf,SAAS;QACX,OAAO;YACL,MAAM,cAAc,OAAO,UAAU,CAAC,gCAAgC,OAAO;YAC7E,SAAS,cAAc,SAAS;QAClC;QAEA,IAAI,oBAAoB;YACtB,gBAAgB;QAClB;QACA,kBAAkB,OAAO,yCAAyC;IACpE,GAAG,EAAE;IAEL,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,CAAC,gBAAgB;QAErB,SAAS,eAAe,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS;QACnD,SAAS,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC;QACvC,aAAa,OAAO,CAAC,uBAAuB;IAC9C,GAAG;QAAC;QAAO;KAAe;IAE1B,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,CAAC,gBAAgB;QAErB,MAAM,kBAAkB,CAAA,GAAA,mHAAA,CAAA,gBAAa,AAAD,EAAE;QACtC,IAAI,iBAAiB;YACnB,SAAS,eAAe,CAAC,KAAK,CAAC,WAAW,CAAC,aAAa;YACxD,SAAS,eAAe,CAAC,KAAK,CAAC,WAAW,CAAC,UAAU;YACrD,SAAS,eAAe,CAAC,KAAK,CAAC,WAAW,CAAC,qBAAqB;YAChE,SAAS,eAAe,CAAC,KAAK,CAAC,WAAW,CAAC,kBAAkB;QAC/D;QACA,aAAa,OAAO,CAAC,+BAA+B;IACtD,GAAG;QAAC;QAAc;KAAe;IAEjC,2EAA2E;IAC3E,yEAAyE;IACzE,qBACE,8OAAC,aAAa,QAAQ;QAAC,OAAO;YAAE;YAAO;YAAU;YAAc;YAAiB;QAAe;kBAC5F;;;;;;AAGP;AAEO,SAAS;IACd,MAAM,UAAU,CAAA,GAAA,qMAAA,CAAA,aAAU,AAAD,EAAE;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 508, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/utils/ClientOnlyWrapper.tsx"],"sourcesContent":["\n\"use client\";\n\nimport { useState, useEffect, type ReactNode } from 'react';\n\ninterface ClientOnlyWrapperProps {\n  children: ReactNode;\n  fallback?: ReactNode; // Optional fallback to show while waiting for mount\n}\n\nexport function ClientOnlyWrapper({ children, fallback = null }: ClientOnlyWrapperProps) {\n  const [hasMounted, setHasMounted] = useState(false);\n\n  useEffect(() => {\n    setHasMounted(true);\n  }, []);\n\n  if (!hasMounted) {\n    return <>{fallback}</>;\n  }\n\n  return <>{children}</>;\n}\n"],"names":[],"mappings":";;;;AAGA;AAFA;;;AASO,SAAS,kBAAkB,EAAE,QAAQ,EAAE,WAAW,IAAI,EAA0B;IACrF,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAE7C,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,cAAc;IAChB,GAAG,EAAE;IAEL,IAAI,CAAC,YAAY;QACf,qBAAO;sBAAG;;IACZ;IAEA,qBAAO;kBAAG;;AACZ","debugId":null}}]
}