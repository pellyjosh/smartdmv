{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/db.config.ts"],"sourcesContent":["import * as pgCore from 'drizzle-orm/pg-core';\nimport * as sqliteCore from 'drizzle-orm/sqlite-core';\n\nconst dbType = process.env.DB_TYPE || 'postgres';\n\nexport const dbTable = (name: string, columns: any, config?: any) => {\n  if (dbType === 'sqlite') {\n    return sqliteCore.sqliteTable(name, columns, config);\n  }\n  return pgCore.pgTable(name, columns, config);\n};\n\nexport const text = (name: string, p0?: { enum: readonly [\"CLIENT\", \"PRACTICE_ADMINISTRATOR\", \"ADMINISTRATOR\"]; }) =>\n  dbType === 'sqlite' ? sqliteCore.text(name) : pgCore.text(name);\n\nexport const integer = (name: string) =>\n  dbType === 'sqlite' ? sqliteCore.integer() : pgCore.integer(name);\n\nexport const primaryKey = dbType === 'sqlite' ? sqliteCore.primaryKey : pgCore.primaryKey;\n\nexport const timestamp = (name: string, p0?: { mode: string; }) =>\n  dbType === 'sqlite' ? sqliteCore.integer() : pgCore.timestamp(name);"],"names":[],"mappings":";;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,OAAO,IAAI;AAE/B,MAAM,UAAU,CAAC,MAAc,SAAc;IAClD,IAAI,WAAW,UAAU;QACvB,OAAO,CAAA,GAAA,yJAAA,CAAA,cAAsB,AAAD,EAAE,MAAM,SAAS;IAC/C;IACA,OAAO,CAAA,GAAA,qJAAA,CAAA,UAAc,AAAD,EAAE,MAAM,SAAS;AACvC;AAEO,MAAM,OAAO,CAAC,MAAc,KACjC,WAAW,WAAW,CAAA,GAAA,mKAAA,CAAA,OAAe,AAAD,EAAE,QAAQ,CAAA,GAAA,+JAAA,CAAA,OAAW,AAAD,EAAE;AAErD,MAAM,UAAU,CAAC,OACtB,WAAW,WAAW,CAAA,GAAA,sKAAA,CAAA,UAAkB,AAAD,MAAM,CAAA,GAAA,kKAAA,CAAA,UAAc,AAAD,EAAE;AAEvD,MAAM,aAAa,WAAW,WAAW,mKAAA,CAAA,aAAqB,GAAG,+JAAA,CAAA,aAAiB;AAElF,MAAM,YAAY,CAAC,MAAc,KACtC,WAAW,WAAW,CAAA,GAAA,sKAAA,CAAA,UAAkB,AAAD,MAAM,CAAA,GAAA,oKAAA,CAAA,YAAgB,AAAD,EAAE","debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schemas/practicesSchema.ts"],"sourcesContent":["import { dbTable, text, timestamp } from '@/db/db.config'; // Removed primaryKey as it's not used here\nimport { relations, sql } from 'drizzle-orm';\nimport { users } from './usersSchema';\nimport { administratorAccessiblePractices } from './usersSchema'; // Keep this if it's the join table\n\nconst isSqlite = process.env.DB_TYPE === 'sqlite';\n\nexport const practices = dbTable('practices', {\n  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),\n  name: text('name').notNull(),\n  createdAt: isSqlite\n    ? timestamp('createdAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`)\n    : timestamp('createdAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n\n  updatedAt: isSqlite\n    ? timestamp('updatedAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`).$onUpdate(() => sql`CURRENT_TIMESTAMP`)\n    : timestamp('updatedAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n});\n\nexport const practicesRelations = relations(practices, ({ many }) => ({\n  usersPractice: many(users, { relationName: 'usersPracticeRelation' }),\n  usersCurrentPractice: many(users, { relationName: 'usersCurrentPracticeRelation' }),\n  accessibleToAdmins: many(administratorAccessiblePractices),\n}));\n"],"names":[],"mappings":";;;;AAAA,iNAA2D,2CAA2C;AACtG;AAAA;AACA;;;;;AAGA,MAAM,WAAW,QAAQ,GAAG,CAAC,OAAO,KAAK;AAElC,MAAM,YAAY,CAAA,GAAA,yHAAA,CAAA,UAAO,AAAD,EAAE,aAAa;IAC5C,IAAI,CAAA,GAAA,yHAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,OAAO,UAAU;IAC9D,MAAM,CAAA,GAAA,yHAAA,CAAA,OAAI,AAAD,EAAE,QAAQ,OAAO;IAC1B,WAAW,WACP,CAAA,GAAA,yHAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAe,GAAG,OAAO,GAAG,OAAO,CAAC,4IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,IACzF,CAAA,GAAA,yHAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAO,GAAG,OAAO,CAAC,4IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,EAAE,OAAO;IAEpF,WAAW,WACP,CAAA,GAAA,yHAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAe,GAAG,OAAO,GAAG,OAAO,CAAC,4IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,EAAE,SAAS,CAAC,IAAM,4IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,IACjI,CAAA,GAAA,yHAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAO,GAAG,OAAO,CAAC,4IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,EAAE,OAAO;AACtF;AAEO,MAAM,qBAAqB,CAAA,GAAA,2IAAA,CAAA,YAAS,AAAD,EAAE,WAAW,CAAC,EAAE,IAAI,EAAE,GAAK,CAAC;QACpE,eAAe,KAAK,mIAAA,CAAA,QAAK,EAAE;YAAE,cAAc;QAAwB;QACnE,sBAAsB,KAAK,mIAAA,CAAA,QAAK,EAAE;YAAE,cAAc;QAA+B;QACjF,oBAAoB,KAAK,mIAAA,CAAA,mCAAgC;IAC3D,CAAC","debugId":null}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schemas/sessionsSchema.ts"],"sourcesContent":["// sessionsSchema.ts\nimport { dbTable, text, timestamp } from '@/db/db.config';\nimport { relations, sql } from 'drizzle-orm';\nimport { users } from './usersSchema';\n\nconst isSqlite = process.env.DB_TYPE === 'sqlite';\n\nexport const sessions = dbTable('sessions', {\n    id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID() as any),\n    userId: text('user_id').notNull().references(() => users.id as any, { onDelete: 'cascade' }),\n    \n    // For SQLite, timestamp (which is integer) can store Unix epoch seconds or milliseconds.\n    // For PG, timestamp with mode: 'date' and withTimezone: true is more appropriate.\n    expiresAt: isSqlite\n      ? timestamp('expiresAt', {mode: 'timestamp_ms'}).notNull() // Drizzle uses integer for SQLite timestamps\n      : timestamp('expiresAt').notNull(),\n\n    data: text('data'), // Assuming JSON stored as text\n    \n    createdAt: isSqlite\n      ? timestamp('createdAt', {mode: 'timestamp_ms'}).notNull().default(sql`CURRENT_TIMESTAMP`)\n      : timestamp('createdAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`)\n  });\n\nexport const sessionsRelations = relations(sessions, ({ one }) => ({\n    user: one(users, {\n      fields: [sessions.userId],\n      references: [users.id],\n    }),\n  }));\n"],"names":[],"mappings":"AAAA,oBAAoB;;;;;AACpB;AACA;AAAA;AACA;;;;AAEA,MAAM,WAAW,QAAQ,GAAG,CAAC,OAAO,KAAK;AAElC,MAAM,WAAW,CAAA,GAAA,yHAAA,CAAA,UAAO,AAAD,EAAE,YAAY;IACxC,IAAI,CAAA,GAAA,yHAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,OAAO,UAAU;IAC9D,QAAQ,CAAA,GAAA,yHAAA,CAAA,OAAI,AAAD,EAAE,WAAW,OAAO,GAAG,UAAU,CAAC,IAAM,mIAAA,CAAA,QAAK,CAAC,EAAE,EAAS;QAAE,UAAU;IAAU;IAE1F,yFAAyF;IACzF,kFAAkF;IAClF,WAAW,WACP,CAAA,GAAA,yHAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAC,MAAM;IAAc,GAAG,OAAO,GAAG,6CAA6C;OACtG,CAAA,GAAA,yHAAA,CAAA,YAAS,AAAD,EAAE,aAAa,OAAO;IAElC,MAAM,CAAA,GAAA,yHAAA,CAAA,OAAI,AAAD,EAAE;IAEX,WAAW,WACP,CAAA,GAAA,yHAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAC,MAAM;IAAc,GAAG,OAAO,GAAG,OAAO,CAAC,4IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,IACvF,CAAA,GAAA,yHAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAO,GAAG,OAAO,GAAG,OAAO,CAAC,4IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC;AACvF;AAEK,MAAM,oBAAoB,CAAA,GAAA,2IAAA,CAAA,YAAS,AAAD,EAAE,UAAU,CAAC,EAAE,GAAG,EAAE,GAAK,CAAC;QAC/D,MAAM,IAAI,mIAAA,CAAA,QAAK,EAAE;YACf,QAAQ;gBAAC,SAAS,MAAM;aAAC;YACzB,YAAY;gBAAC,mIAAA,CAAA,QAAK,CAAC,EAAE;aAAC;QACxB;IACF,CAAC","debugId":null}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schemas/usersSchema.ts"],"sourcesContent":["// schema/usersSchema.ts\nimport { dbTable, text, timestamp, primaryKey } from '@/db/db.config';\nimport { relations, sql } from 'drizzle-orm';\nimport { practices } from './practicesSchema';\nimport { sessions } from './sessionsSchema';\n\nconst isSqlite = process.env.DB_TYPE === 'sqlite';\n\nexport const userRoleEnum = ['CLIENT', 'PRACTICE_ADMINISTRATOR', 'ADMINISTRATOR'] as const;\n\nexport const users = dbTable('users', {\n  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),\n  email: text('email').notNull().unique(),\n  name: text('name'),\n  password: text('password').notNull(),\n  role: text('role', { enum: userRoleEnum }).notNull(),\n  practiceId: text('practice_id').references(() => practices.id as any, { onDelete: 'set null' }),\n  currentPracticeId: text('current_practice_id').references(() => practices.id as any, { onDelete: 'set null' }),\n\n  createdAt: isSqlite\n    ? timestamp('createdAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`)\n    : timestamp('createdAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n\n  updatedAt: isSqlite\n    ? timestamp('updatedAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`).$onUpdate(() => sql`CURRENT_TIMESTAMP`)\n    : timestamp('createdAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n});\n\nexport const administratorAccessiblePractices = dbTable('administrator_accessible_practices', {\n  administratorId: text('administrator_id').notNull().references(() => users.id as any, { onDelete: 'cascade' }),\n  practiceId: text('practice_id').notNull().references(() => practices.id as any, { onDelete: 'cascade' }),\n\n  assignedAt: isSqlite\n    ? timestamp('assignedAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`)\n    : timestamp('assignedAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`),\n\n  createdAt: isSqlite\n    ? timestamp('createdAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`)\n    : timestamp('createdAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`),\n\n  updatedAt: isSqlite\n    ? timestamp('updatedAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`).$onUpdate(() => sql`CURRENT_TIMESTAMP`)\n    : timestamp('updatedAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`),\n}, (table: { administratorId: any; practiceId: any; }) => ({\n  pk: primaryKey({ columns: [table.administratorId, table.practiceId] }),\n}));\n\nexport const usersRelations = relations(users, ({ one, many }) => ({\n  assignedPractice: one(practices, {\n    fields: [users.practiceId],\n    references: [practices.id],\n    relationName: 'usersPracticeRelation',\n  }),\n  currentSelectedPractice: one(practices, {\n    fields: [users.currentPracticeId],\n    references: [practices.id],\n    relationName: 'usersCurrentPracticeRelation',\n  }),\n  accessiblePractices: many(administratorAccessiblePractices),\n  sessions: many(sessions),\n}));\n\nexport const administratorAccessiblePracticesRelations = relations(administratorAccessiblePractices, ({ one }) => ({\n  administrator: one(users, {\n    fields: [administratorAccessiblePractices.administratorId],\n    references: [users.id],\n  }),\n  practice: one(practices, {\n    fields: [administratorAccessiblePractices.practiceId],\n    references: [practices.id],\n  }),\n}));\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schema.ts"],"sourcesContent":["import { users, administratorAccessiblePractices } from './schemas/usersSchema';\nimport { practices } from './schemas/practicesSchema';\nimport { sessions } from './schemas/sessionsSchema';\nexport const schema = {\n  users,\n  practices,\n  sessions,\n  administratorAccessiblePractices,\n};\n\n// Re-export all tables and their relations for Drizzle to use\nexport * from './schemas/practicesSchema';\nexport * from './schemas/sessionsSchema';\nexport * from './schemas/usersSchema';"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACO,MAAM,SAAS;IACpB,OAAA,mIAAA,CAAA,QAAK;IACL,WAAA,uIAAA,CAAA,YAAS;IACT,UAAA,sIAAA,CAAA,WAAQ;IACR,kCAAA,mIAAA,CAAA,mCAAgC;AAClC","debugId":null}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/index.ts"],"sourcesContent":["\nimport { config } from 'dotenv';\nconfig(); // Load environment variables at the very top\n\n// index.ts\nimport { drizzle as drizzlePostgres } from 'drizzle-orm/node-postgres';\nimport { drizzle as drizzleSqlite } from 'drizzle-orm/better-sqlite3';\nimport { Pool } from 'pg';\nimport Database from 'better-sqlite3';\nimport * as schema from './schema';\n\n// âœ… Extend globalThis for custom caching variables\ndeclare global {\n  // biome-ignore lint/style/noVar: This is needed for global declarations\n  var DrizzlePostgresClient: Pool | undefined;\n  var DrizzleSqliteClient: ReturnType<typeof Database> | undefined;\n}\n\n// âœ… Ensure this file is treated as a module\nexport {};\n\nlet dbInstance: ReturnType<typeof drizzlePostgres> | ReturnType<typeof drizzleSqlite>;\n\nconst dbType = process.env.DB_TYPE || 'postgres'; // Default to PostgreSQL\nconsole.log(`[DB_INIT] DB_TYPE set to: ${dbType}`);\n\n\nif (dbType === 'postgres') {\n  if (!process.env.POSTGRES_URL) {\n    throw new Error('POSTGRES_URL environment variable is not set for DB_TYPE=\"postgres\".');\n  }\n\n  console.log('ðŸ”Œ Connecting to PostgreSQL database...');\n\n  let poolClient: Pool;\n  if (process.env.NODE_ENV === 'production') {\n    poolClient = new Pool({ connectionString: process.env.POSTGRES_URL });\n  } else {\n    if (!global.DrizzlePostgresClient) {\n      global.DrizzlePostgresClient = new Pool({ connectionString: process.env.POSTGRES_URL });\n      console.log('[DB_INIT] New PostgreSQL global client created for development.');\n    } else {\n      console.log('[DB_INIT] Reusing existing PostgreSQL global client for development.');\n    }\n    poolClient = global.DrizzlePostgresClient;\n  }\n\n  dbInstance = drizzlePostgres(poolClient, {\n    schema,\n    logger: process.env.NODE_ENV === 'development',\n  });\n  console.log('âœ… PostgreSQL Drizzle instance created.');\n\n} else if (dbType === 'sqlite') {\n  if (!process.env.SQLITE_DB_PATH) {\n    throw new Error('SQLITE_DB_PATH environment variable is not set for DB_TYPE=\"sqlite\".');\n  }\n\n  console.log(`ðŸ”Œ Connecting to SQLite database at: ${process.env.SQLITE_DB_PATH}`);\n\n  let sqliteClient: ReturnType<typeof Database>;\n\n  if (process.env.NODE_ENV === 'production') {\n    sqliteClient = new Database(process.env.SQLITE_DB_PATH);\n  } else {\n    if (!global.DrizzleSqliteClient) {\n      global.DrizzleSqliteClient = new Database(process.env.SQLITE_DB_PATH);\n      console.log('[DB_INIT] New SQLite global client created for development.');\n    } else {\n      console.log('[DB_INIT] Reusing existing SQLite global client for development.');\n    }\n    sqliteClient = global.DrizzleSqliteClient;\n  }\n\n  dbInstance = drizzleSqlite(sqliteClient, {\n    schema,\n    logger: process.env.NODE_ENV === 'development',\n  });\n  console.log('âœ… SQLite Drizzle instance created.');\n\n} else {\n  throw new Error(`Unsupported DB_TYPE: ${dbType}. Must be \"postgres\" or \"sqlite\".`);\n}\n\nexport const db = dbInstance;\n"],"names":[],"mappings":";;;AACA;AAGA,WAAW;AACX;AACA;AACA;AACA;AACA;AAAA;;;;;;;AAPA,CAAA,GAAA,qIAAA,CAAA,SAAM,AAAD,KAAK,6CAA6C;;;;;;AAmBvD,IAAI;AAEJ,MAAM,SAAS,QAAQ,GAAG,CAAC,OAAO,IAAI,YAAY,wBAAwB;AAC1E,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,QAAQ;AAGjD,IAAI,WAAW,YAAY;IACzB,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAE;QAC7B,MAAM,IAAI,MAAM;IAClB;IAEA,QAAQ,GAAG,CAAC;IAEZ,IAAI;IACJ,uCAA2C;;IAE3C,OAAO;QACL,IAAI,CAAC,OAAO,qBAAqB,EAAE;YACjC,OAAO,qBAAqB,GAAG,IAAI,oGAAA,CAAA,OAAI,CAAC;gBAAE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;YAAC;YACrF,QAAQ,GAAG,CAAC;QACd,OAAO;YACL,QAAQ,GAAG,CAAC;QACd;QACA,aAAa,OAAO,qBAAqB;IAC3C;IAEA,aAAa,CAAA,GAAA,4JAAA,CAAA,UAAe,AAAD,EAAE,YAAY;QACvC,QAAA;QACA,QAAQ,oDAAyB;IACnC;IACA,QAAQ,GAAG,CAAC;AAEd,OAAO,IAAI,WAAW,UAAU;IAC9B,IAAI,CAAC,QAAQ,GAAG,CAAC,cAAc,EAAE;QAC/B,MAAM,IAAI,MAAM;IAClB;IAEA,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,QAAQ,GAAG,CAAC,cAAc,EAAE;IAEhF,IAAI;IAEJ,uCAA2C;;IAE3C,OAAO;QACL,IAAI,CAAC,OAAO,mBAAmB,EAAE;YAC/B,OAAO,mBAAmB,GAAG,IAAI,2HAAA,CAAA,UAAQ,CAAC,QAAQ,GAAG,CAAC,cAAc;YACpE,QAAQ,GAAG,CAAC;QACd,OAAO;YACL,QAAQ,GAAG,CAAC;QACd;QACA,eAAe,OAAO,mBAAmB;IAC3C;IAEA,aAAa,CAAA,GAAA,6JAAA,CAAA,UAAa,AAAD,EAAE,cAAc;QACvC,QAAA;QACA,QAAQ,oDAAyB;IACnC;IACA,QAAQ,GAAG,CAAC;AAEd,OAAO;IACL,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,OAAO,iCAAiC,CAAC;AACnF;AAEO,MAAM,KAAK","debugId":null}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/authActions.ts"],"sourcesContent":["\n'use server';\n\nimport { db } from '@/db';\nimport { users as usersTable, administratorAccessiblePractices as adminPracticesTable } from '@/db/schema';\nimport { eq } from 'drizzle-orm';\nimport bcrypt from 'bcryptjs';\nimport type { User, AdministratorUser } from '@/context/UserContext'; // Use User types from UserContext\n\nexport async function loginUserAction(emailInput: string, passwordInput: string): Promise<User> {\n  const result = await db.select().from(usersTable).where(eq(usersTable.email, emailInput)).limit(1);\n  const dbUser = result[0];\n\n  if (!dbUser || !dbUser.password) {\n    throw new Error('User not found or password not set.');\n  }\n\n  const passwordMatch = bcrypt.compareSync(passwordInput, dbUser.password);\n  if (!passwordMatch) {\n    throw new Error('Invalid credentials. Please try again.');\n  }\n\n  let userData: User;\n\n  if (dbUser.role === 'ADMINISTRATOR') {\n    const adminPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n      .from(adminPracticesTable)\n      .where(eq(adminPracticesTable.administratorId, dbUser.id));\n    \n    const accessiblePracticeIds = adminPractices.map(p => p.practiceId);\n    let currentPracticeId = dbUser.currentPracticeId;\n\n    if (!currentPracticeId && accessiblePracticeIds.length > 0) {\n      currentPracticeId = accessiblePracticeIds[0];\n    } else if (!currentPracticeId && accessiblePracticeIds.length === 0) {\n      console.warn(`Administrator ${dbUser.email} has no current or accessible practices configured.`);\n      currentPracticeId = 'practice_NONE'; // Fallback\n    }\n\n    userData = {\n      id: dbUser.id,\n      email: dbUser.email,\n      name: dbUser.name || undefined,\n      role: 'ADMINISTRATOR',\n      accessiblePracticeIds,\n      currentPracticeId: currentPracticeId!,\n    };\n  } else if (dbUser.role === 'PRACTICE_ADMINISTRATOR') {\n    if (!dbUser.practiceId) {\n      throw new Error('Practice Administrator is not associated with a practice.');\n    }\n    userData = {\n      id: dbUser.id,\n      email: dbUser.email,\n      name: dbUser.name || undefined,\n      role: 'PRACTICE_ADMINISTRATOR',\n      practiceId: dbUser.practiceId,\n    };\n  } else if (dbUser.role === 'CLIENT') {\n    if (!dbUser.practiceId) {\n      throw new Error('Client is not associated with a practice.');\n    }\n    userData = {\n      id: dbUser.id,\n      email: dbUser.email,\n      name: dbUser.name || undefined,\n      role: 'CLIENT',\n      practiceId: dbUser.practiceId,\n    };\n  } else {\n    throw new Error('Unknown user role.');\n  }\n  return userData;\n}\n\nexport async function switchPracticeAction(userId: string, newPracticeId: string): Promise<{ success: boolean; updatedUser?: User }> {\n  try {\n    // First, verify the user exists and is an administrator\n    const userResult = await db.select({ role: usersTable.role }).from(usersTable).where(eq(usersTable.id, userId)).limit(1);\n    if (!userResult[0] || userResult[0].role !== 'ADMINISTRATOR') {\n      throw new Error(\"User not found or not an administrator.\");\n    }\n\n    // We should also verify if newPracticeId is one of the admin's accessiblePracticeIds\n    // For now, proceeding with update. A full implementation would fetch accessible IDs again here or ensure client provides valid one.\n    const adminUserPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n      .from(adminPracticesTable)\n      .where(eq(adminPracticesTable.administratorId, userId));\n    if (!adminUserPractices.map(p => p.practiceId).includes(newPracticeId)) {\n        throw new Error(\"Administrator does not have access to this practice.\");\n    }\n\n\n    await db.update(usersTable)\n      .set({ currentPracticeId: newPracticeId })\n      .where(eq(usersTable.id, userId));\n    \n     const updatedDbUser = await db.select().from(usersTable).where(eq(usersTable.id, userId)).limit(1);\n     if(!updatedDbUser[0]) {\n        throw new Error(\"Failed to refetch user after update.\")\n     }\n    const adminPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n      .from(adminPracticesTable)\n      .where(eq(adminPracticesTable.administratorId, updatedDbUser[0].id));\n    const accessiblePracticeIds = adminPractices.map(p => p.practiceId);\n\n\n    const refreshedUser: AdministratorUser = { // Be specific with type\n        id: updatedDbUser[0].id,\n        email: updatedDbUser[0].email,\n        name: updatedDbUser[0].name || undefined,\n        role: 'ADMINISTRATOR',\n        accessiblePracticeIds: accessiblePracticeIds,\n        currentPracticeId: newPracticeId,\n    }\n\n    return { success: true, updatedUser: refreshedUser };\n  } catch (error) {\n    console.error(\"Failed to switch practice:\", error);\n    if (error instanceof Error) {\n        return { success: false, updatedUser: undefined }; // Consider returning error message\n    }\n    return { success: false };\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 604, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 679, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx"],"sourcesContent":["// This file is intentionally left blank.\n// The root route '/' is handled by /src/app/(main)/page.tsx\n// due to the (main) route group setup.\n"],"names":[],"mappings":"AAAA,yCAAyC;AACzC,4DAA4D;AAC5D,uCAAuC","debugId":null}}]
}