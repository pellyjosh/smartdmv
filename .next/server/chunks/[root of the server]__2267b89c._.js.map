{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/db.config.ts"],"sourcesContent":["import * as pgCore from 'drizzle-orm/pg-core';\nimport * as sqliteCore from 'drizzle-orm/sqlite-core';\n\nconst dbType = process.env.DB_TYPE || 'postgres';\n\nexport const dbTable = (name: string, columns: any, config?: any) => {\n  if (dbType === 'sqlite') {\n    return sqliteCore.sqliteTable(name, columns, config);\n  }\n  return pgCore.pgTable(name, columns, config);\n};\n\nexport const text = (name: string, p0?: { enum: readonly [\"CLIENT\", \"PRACTICE_ADMINISTRATOR\", \"ADMINISTRATOR\"]; }) =>\n  dbType === 'sqlite' ? sqliteCore.text(name) : pgCore.text(name);\n\nexport const integer = (name: string) =>\n  dbType === 'sqlite' ? sqliteCore.integer() : pgCore.integer(name);\n\nexport const primaryKey = dbType === 'sqlite' ? sqliteCore.primaryKey : pgCore.primaryKey;\n\nexport const timestamp = (name: string, p0?: { mode: string; }) =>\n  dbType === 'sqlite' ? sqliteCore.integer() : pgCore.timestamp(name);"],"names":[],"mappings":";;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,OAAO,IAAI;AAE/B,MAAM,UAAU,CAAC,MAAc,SAAc;IAClD,IAAI,WAAW,UAAU;QACvB,OAAO,CAAA,GAAA,2JAAA,CAAA,cAAsB,AAAD,EAAE,MAAM,SAAS;IAC/C;IACA,OAAO,CAAA,GAAA,uJAAA,CAAA,UAAc,AAAD,EAAE,MAAM,SAAS;AACvC;AAEO,MAAM,OAAO,CAAC,MAAc,KACjC,WAAW,WAAW,CAAA,GAAA,qKAAA,CAAA,OAAe,AAAD,EAAE,QAAQ,CAAA,GAAA,iKAAA,CAAA,OAAW,AAAD,EAAE;AAErD,MAAM,UAAU,CAAC,OACtB,WAAW,WAAW,CAAA,GAAA,wKAAA,CAAA,UAAkB,AAAD,MAAM,CAAA,GAAA,oKAAA,CAAA,UAAc,AAAD,EAAE;AAEvD,MAAM,aAAa,WAAW,WAAW,qKAAA,CAAA,aAAqB,GAAG,iKAAA,CAAA,aAAiB;AAElF,MAAM,YAAY,CAAC,MAAc,KACtC,WAAW,WAAW,CAAA,GAAA,wKAAA,CAAA,UAAkB,AAAD,MAAM,CAAA,GAAA,sKAAA,CAAA,YAAgB,AAAD,EAAE","debugId":null}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schemas/practicesSchema.ts"],"sourcesContent":["import { dbTable, text, timestamp } from '@/db/db.config'; // Removed primaryKey as it's not used here\nimport { relations, sql } from 'drizzle-orm';\nimport { users } from './usersSchema';\nimport { administratorAccessiblePractices } from './usersSchema'; // Keep this if it's the join table\n\nconst isSqlite = process.env.DB_TYPE === 'sqlite';\n\nexport const practices = dbTable('practices', {\n  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),\n  name: text('name').notNull(),\n  createdAt: isSqlite\n    ? timestamp('createdAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`)\n    : timestamp('createdAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n\n  updatedAt: isSqlite\n    ? timestamp('updatedAt', { mode: 'timestamp_ms' }).notNull().default(sql`CURRENT_TIMESTAMP`).$onUpdate(() => sql`CURRENT_TIMESTAMP`)\n    : timestamp('updatedAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n});\n\nexport const practicesRelations = relations(practices, ({ many }) => ({\n  usersPractice: many(users, { relationName: 'usersPracticeRelation' }),\n  usersCurrentPractice: many(users, { relationName: 'usersCurrentPracticeRelation' }),\n  accessibleToAdmins: many(administratorAccessiblePractices),\n}));\n"],"names":[],"mappings":";;;;AAAA,qNAA2D,2CAA2C;AACtG;AAAA;AACA;;;;;AAGA,MAAM,WAAW,QAAQ,GAAG,CAAC,OAAO,KAAK;AAElC,MAAM,YAAY,CAAA,GAAA,2HAAA,CAAA,UAAO,AAAD,EAAE,aAAa;IAC5C,IAAI,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,OAAO,UAAU;IAC9D,MAAM,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE,QAAQ,OAAO;IAC1B,WAAW,WACP,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAe,GAAG,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,IACzF,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,EAAE,OAAO;IAEpF,WAAW,WACP,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAe,GAAG,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,EAAE,SAAS,CAAC,IAAM,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,IACjI,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,EAAE,OAAO;AACtF;AAEO,MAAM,qBAAqB,CAAA,GAAA,6IAAA,CAAA,YAAS,AAAD,EAAE,WAAW,CAAC,EAAE,IAAI,EAAE,GAAK,CAAC;QACpE,eAAe,KAAK,qIAAA,CAAA,QAAK,EAAE;YAAE,cAAc;QAAwB;QACnE,sBAAsB,KAAK,qIAAA,CAAA,QAAK,EAAE;YAAE,cAAc;QAA+B;QACjF,oBAAoB,KAAK,qIAAA,CAAA,mCAAgC;IAC3D,CAAC","debugId":null}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schemas/sessionsSchema.ts"],"sourcesContent":["// sessionsSchema.ts\nimport { dbTable, text, timestamp } from '@/db/db.config';\nimport { relations, sql } from 'drizzle-orm';\nimport { users } from './usersSchema';\n\nconst isSqlite = process.env.DB_TYPE === 'sqlite';\n\nexport const sessions = dbTable('sessions', {\n    id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID() as any),\n    userId: text('user_id').notNull().references(() => users.id as any, { onDelete: 'cascade' }),\n    \n    // For SQLite, timestamp (which is integer) can store Unix epoch seconds or milliseconds.\n    // For PG, timestamp with mode: 'date' and withTimezone: true is more appropriate.\n    expiresAt: isSqlite\n      ? timestamp('expiresAt', {mode: 'timestamp_ms'}).notNull() // Drizzle uses integer for SQLite timestamps\n      : timestamp('expiresAt').notNull(),\n\n    data: text('data'), // Assuming JSON stored as text\n    \n    createdAt: isSqlite\n      ? timestamp('createdAt', {mode: 'timestamp_ms'}).notNull().default(sql`CURRENT_TIMESTAMP`)\n      : timestamp('createdAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`)\n  });\n\nexport const sessionsRelations = relations(sessions, ({ one }) => ({\n    user: one(users, {\n      fields: [sessions.userId],\n      references: [users.id],\n    }),\n  }));\n"],"names":[],"mappings":"AAAA,oBAAoB;;;;;AACpB;AACA;AAAA;AACA;;;;AAEA,MAAM,WAAW,QAAQ,GAAG,CAAC,OAAO,KAAK;AAElC,MAAM,WAAW,CAAA,GAAA,2HAAA,CAAA,UAAO,AAAD,EAAE,YAAY;IACxC,IAAI,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,OAAO,UAAU;IAC9D,QAAQ,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE,WAAW,OAAO,GAAG,UAAU,CAAC,IAAM,qIAAA,CAAA,QAAK,CAAC,EAAE,EAAS;QAAE,UAAU;IAAU;IAE1F,yFAAyF;IACzF,kFAAkF;IAClF,WAAW,WACP,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAC,MAAM;IAAc,GAAG,OAAO,GAAG,6CAA6C;OACtG,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa,OAAO;IAElC,MAAM,CAAA,GAAA,2HAAA,CAAA,OAAI,AAAD,EAAE;IAEX,WAAW,WACP,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAC,MAAM;IAAc,GAAG,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,IACvF,CAAA,GAAA,2HAAA,CAAA,YAAS,AAAD,EAAE,aAAa;QAAE,MAAM;IAAO,GAAG,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC;AACvF;AAEK,MAAM,oBAAoB,CAAA,GAAA,6IAAA,CAAA,YAAS,AAAD,EAAE,UAAU,CAAC,EAAE,GAAG,EAAE,GAAK,CAAC;QAC/D,MAAM,IAAI,qIAAA,CAAA,QAAK,EAAE;YACf,QAAQ;gBAAC,SAAS,MAAM;aAAC;YACzB,YAAY;gBAAC,qIAAA,CAAA,QAAK,CAAC,EAAE;aAAC;QACxB;IACF,CAAC","debugId":null}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schemas/usersSchema.ts"],"sourcesContent":["\n// schema/usersSchema.ts\nimport { dbTable, text, timestamp, primaryKey } from '@/db/db.config';\nimport { relations, sql } from 'drizzle-orm';\nimport { practices } from './practicesSchema';\nimport { sessions } from './sessionsSchema';\n\nconst isSqlite = process.env.DB_TYPE === 'sqlite';\n\nexport const userRoleEnum = ['CLIENT', 'PRACTICE_ADMINISTRATOR', 'ADMINISTRATOR'] as const;\n\nexport const users = dbTable('users', {\n  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),\n  email: text('email').notNull().unique(),\n  name: text('name'),\n  password: text('password').notNull(),\n  role: text('role', { enum: userRoleEnum }).notNull(),\n  practiceId: text('practice_id').references(() => practices.id as any, { onDelete: 'set null' }),\n  currentPracticeId: text('current_practice_id').references(() => practices.id as any, { onDelete: 'set null' }),\n\n  createdAt: isSqlite\n    ? timestamp('createdAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('createdAt', { mode: 'date' }).default(sql`CURRENT_TIMESTAMP`).notNull(),\n\n  updatedAt: isSqlite\n    ? timestamp('updatedAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`).$onUpdate(() => sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('updatedAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`).$onUpdateFn(() => new Date()),\n});\n\nexport const administratorAccessiblePractices = dbTable('administrator_accessible_practices', {\n  administratorId: text('administrator_id').notNull().references(() => users.id as any, { onDelete: 'cascade' }),\n  practiceId: text('practice_id').notNull().references(() => practices.id as any, { onDelete: 'cascade' }),\n\n  assignedAt: isSqlite\n    ? timestamp('assignedAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('assignedAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`),\n\n  createdAt: isSqlite\n    ? timestamp('createdAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('createdAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`),\n\n  updatedAt: isSqlite\n    ? timestamp('updatedAt', { mode: 'timestamp_ms' }).notNull().default(sql`(strftime('%s', 'now') * 1000)`).$onUpdate(() => sql`(strftime('%s', 'now') * 1000)`)\n    : timestamp('updatedAt', { mode: 'date' }).notNull().default(sql`CURRENT_TIMESTAMP`).$onUpdateFn(() => new Date()),\n}, (table: { administratorId: any; practiceId: any; }) => ({\n  pk: primaryKey({ columns: [table.administratorId, table.practiceId] }),\n}));\n\nexport const usersRelations = relations(users, ({ one, many }) => ({\n  assignedPractice: one(practices, {\n    fields: [users.practiceId],\n    references: [practices.id],\n    relationName: 'usersPracticeRelation',\n  }),\n  currentSelectedPractice: one(practices, {\n    fields: [users.currentPracticeId],\n    references: [practices.id],\n    relationName: 'usersCurrentPracticeRelation',\n  }),\n  accessiblePractices: many(administratorAccessiblePractices),\n  sessions: many(sessions),\n}));\n\nexport const administratorAccessiblePracticesRelations = relations(administratorAccessiblePractices, ({ one }) => ({\n  administrator: one(users, {\n    fields: [administratorAccessiblePractices.administratorId],\n    references: [users.id],\n  }),\n  practice: one(practices, {\n    fields: [administratorAccessiblePractices.practiceId],\n    references: [practices.id],\n  }),\n}));\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/schema.ts"],"sourcesContent":["import { users, administratorAccessiblePractices } from './schemas/usersSchema';\nimport { practices } from './schemas/practicesSchema';\nimport { sessions } from './schemas/sessionsSchema';\nexport const schema = {\n  users,\n  practices,\n  sessions,\n  administratorAccessiblePractices,\n};\n\n// Re-export all tables and their relations for Drizzle to use\nexport * from './schemas/practicesSchema';\nexport * from './schemas/sessionsSchema';\nexport * from './schemas/usersSchema';"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACO,MAAM,SAAS;IACpB,OAAA,qIAAA,CAAA,QAAK;IACL,WAAA,yIAAA,CAAA,YAAS;IACT,UAAA,wIAAA,CAAA,WAAQ;IACR,kCAAA,qIAAA,CAAA,mCAAgC;AAClC","debugId":null}},
    {"offset": {"line": 435, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/db/index.ts"],"sourcesContent":["\nimport { config } from 'dotenv';\nconfig(); // Load environment variables at the very top\n\n// index.ts\nimport { drizzle as drizzlePostgres } from 'drizzle-orm/node-postgres';\nimport { drizzle as drizzleSqlite } from 'drizzle-orm/better-sqlite3';\nimport { Pool } from 'pg';\nimport Database from 'better-sqlite3';\nimport * as schema from './schema';\n\n// ✅ Extend globalThis for custom caching variables\ndeclare global {\n  // biome-ignore lint/style/noVar: This is needed for global declarations\n  var DrizzlePostgresClient: Pool | undefined;\n  var DrizzleSqliteClient: ReturnType<typeof Database> | undefined;\n}\n\n// ✅ Ensure this file is treated as a module\nexport {};\n\nlet dbInstance: ReturnType<typeof drizzlePostgres> | ReturnType<typeof drizzleSqlite>;\n\nconst dbType = process.env.DB_TYPE || 'postgres'; // Default to PostgreSQL\nconsole.log(`[DB_INIT] DB_TYPE set to: ${dbType}`);\n\n\nif (dbType === 'postgres') {\n  if (!process.env.POSTGRES_URL) {\n    throw new Error('POSTGRES_URL environment variable is not set for DB_TYPE=\"postgres\".');\n  }\n\n  console.log('🔌 Connecting to PostgreSQL database...');\n\n  let poolClient: Pool;\n  if (process.env.NODE_ENV === 'production') {\n    poolClient = new Pool({ connectionString: process.env.POSTGRES_URL });\n  } else {\n    if (!global.DrizzlePostgresClient) {\n      global.DrizzlePostgresClient = new Pool({ connectionString: process.env.POSTGRES_URL });\n      console.log('[DB_INIT] New PostgreSQL global client created for development.');\n    } else {\n      console.log('[DB_INIT] Reusing existing PostgreSQL global client for development.');\n    }\n    poolClient = global.DrizzlePostgresClient;\n  }\n\n  dbInstance = drizzlePostgres(poolClient, {\n    schema,\n    logger: process.env.NODE_ENV === 'development',\n  });\n  console.log('✅ PostgreSQL Drizzle instance created.');\n\n} else if (dbType === 'sqlite') {\n  if (!process.env.SQLITE_DB_PATH) {\n    throw new Error('SQLITE_DB_PATH environment variable is not set for DB_TYPE=\"sqlite\".');\n  }\n\n  console.log(`🔌 Connecting to SQLite database at: ${process.env.SQLITE_DB_PATH}`);\n\n  let sqliteClient: ReturnType<typeof Database>;\n\n  if (process.env.NODE_ENV === 'production') {\n    sqliteClient = new Database(process.env.SQLITE_DB_PATH);\n  } else {\n    if (!global.DrizzleSqliteClient) {\n      global.DrizzleSqliteClient = new Database(process.env.SQLITE_DB_PATH);\n      console.log('[DB_INIT] New SQLite global client created for development.');\n    } else {\n      console.log('[DB_INIT] Reusing existing SQLite global client for development.');\n    }\n    sqliteClient = global.DrizzleSqliteClient;\n  }\n\n  dbInstance = drizzleSqlite(sqliteClient, {\n    schema,\n    logger: process.env.NODE_ENV === 'development',\n  });\n  console.log('✅ SQLite Drizzle instance created.');\n\n} else {\n  throw new Error(`Unsupported DB_TYPE: ${dbType}. Must be \"postgres\" or \"sqlite\".`);\n}\n\nexport const db = dbInstance;\n"],"names":[],"mappings":";;;AACA;AAGA,WAAW;AACX;AACA;AACA;AACA;AACA;AAAA;;;;;;;AAPA,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,KAAK,6CAA6C;;;;;;AAmBvD,IAAI;AAEJ,MAAM,SAAS,QAAQ,GAAG,CAAC,OAAO,IAAI,YAAY,wBAAwB;AAC1E,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,QAAQ;AAGjD,IAAI,WAAW,YAAY;IACzB,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAE;QAC7B,MAAM,IAAI,MAAM;IAClB;IAEA,QAAQ,GAAG,CAAC;IAEZ,IAAI;IACJ,uCAA2C;;IAE3C,OAAO;QACL,IAAI,CAAC,OAAO,qBAAqB,EAAE;YACjC,OAAO,qBAAqB,GAAG,IAAI,oGAAA,CAAA,OAAI,CAAC;gBAAE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;YAAC;YACrF,QAAQ,GAAG,CAAC;QACd,OAAO;YACL,QAAQ,GAAG,CAAC;QACd;QACA,aAAa,OAAO,qBAAqB;IAC3C;IAEA,aAAa,CAAA,GAAA,8JAAA,CAAA,UAAe,AAAD,EAAE,YAAY;QACvC,QAAA;QACA,QAAQ,oDAAyB;IACnC;IACA,QAAQ,GAAG,CAAC;AAEd,OAAO,IAAI,WAAW,UAAU;IAC9B,IAAI,CAAC,QAAQ,GAAG,CAAC,cAAc,EAAE;QAC/B,MAAM,IAAI,MAAM;IAClB;IAEA,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,QAAQ,GAAG,CAAC,cAAc,EAAE;IAEhF,IAAI;IAEJ,uCAA2C;;IAE3C,OAAO;QACL,IAAI,CAAC,OAAO,mBAAmB,EAAE;YAC/B,OAAO,mBAAmB,GAAG,IAAI,2HAAA,CAAA,UAAQ,CAAC,QAAQ,GAAG,CAAC,cAAc;YACpE,QAAQ,GAAG,CAAC;QACd,OAAO;YACL,QAAQ,GAAG,CAAC;QACd;QACA,eAAe,OAAO,mBAAmB;IAC3C;IAEA,aAAa,CAAA,GAAA,+JAAA,CAAA,UAAa,AAAD,EAAE,cAAc;QACvC,QAAA;QACA,QAAQ,oDAAyB;IACnC;IACA,QAAQ,GAAG,CAAC;AAEd,OAAO;IACL,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,OAAO,iCAAiC,CAAC;AACnF;AAEO,MAAM,KAAK","debugId":null}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/authActions.ts"],"sourcesContent":["\n'use server';\n\nimport { db } from '@/db';\nimport { users as usersTable, administratorAccessiblePractices as adminPracticesTable } from '@/db/schema';\nimport { eq } from 'drizzle-orm';\nimport bcrypt from 'bcryptjs';\nimport type { User, AdministratorUser } from '@/context/UserContext'; // Use User types from UserContext\n\nexport async function loginUserAction(emailInput: string, passwordInput: string): Promise<User> {\n  const result = await db.select().from(usersTable).where(eq(usersTable.email, emailInput)).limit(1);\n  const dbUser = result[0];\n\n  if (!dbUser || !dbUser.password) {\n    throw new Error('User not found or password not set.');\n  }\n\n  const passwordMatch = bcrypt.compareSync(passwordInput, dbUser.password);\n  if (!passwordMatch) {\n    throw new Error('Invalid credentials. Please try again.');\n  }\n\n  let userData: User;\n\n  if (dbUser.role === 'ADMINISTRATOR') {\n    const adminPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n      .from(adminPracticesTable)\n      .where(eq(adminPracticesTable.administratorId, dbUser.id));\n    \n    const accessiblePracticeIds = adminPractices.map(p => p.practiceId);\n    let currentPracticeId = dbUser.currentPracticeId;\n\n    if (!currentPracticeId && accessiblePracticeIds.length > 0) {\n      currentPracticeId = accessiblePracticeIds[0];\n    } else if (accessiblePracticeIds.length === 0) { \n      console.warn(`[AuthAction loginUserAction] Administrator ${dbUser.email} has no current or accessible practices configured.`);\n      currentPracticeId = 'practice_NONE'; // Fallback\n    } else if (currentPracticeId && !accessiblePracticeIds.includes(currentPracticeId) && accessiblePracticeIds.length > 0) {\n        console.warn(`[AuthAction loginUserAction] Administrator ${dbUser.email}'s currentPracticeId ${currentPracticeId} is not in accessible list. Defaulting to first accessible.`);\n        currentPracticeId = accessiblePracticeIds[0];\n    }\n\n\n    userData = {\n      id: dbUser.id,\n      email: dbUser.email,\n      name: dbUser.name || undefined,\n      role: 'ADMINISTRATOR',\n      accessiblePracticeIds,\n      currentPracticeId: currentPracticeId!,\n    };\n  } else if (dbUser.role === 'PRACTICE_ADMINISTRATOR') {\n    if (!dbUser.practiceId) {\n      throw new Error('Practice Administrator is not associated with a practice.');\n    }\n    userData = {\n      id: dbUser.id,\n      email: dbUser.email,\n      name: dbUser.name || undefined,\n      role: 'PRACTICE_ADMINISTRATOR',\n      practiceId: dbUser.practiceId,\n    };\n  } else if (dbUser.role === 'CLIENT') {\n    if (!dbUser.practiceId) {\n      throw new Error('Client is not associated with a practice.');\n    }\n    userData = {\n      id: dbUser.id,\n      email: dbUser.email,\n      name: dbUser.name || undefined,\n      role: 'CLIENT',\n      practiceId: dbUser.practiceId,\n    };\n  } else {\n    throw new Error('Unknown user role.');\n  }\n  return userData;\n}\n\nexport async function switchPracticeAction(userId: string, newPracticeId: string): Promise<{ success: boolean; updatedUser?: User }> {\n  console.log(`[AuthAction switchPracticeAction] User ${userId} attempting to switch to practice ${newPracticeId}`);\n  try {\n    const userResult = await db.select({ role: usersTable.role }).from(usersTable).where(eq(usersTable.id, userId)).limit(1);\n    if (!userResult[0] || userResult[0].role !== 'ADMINISTRATOR') {\n      console.error(`[AuthAction switchPracticeAction] User ${userId} not found or not an administrator.`);\n      throw new Error(\"User not found or not an administrator.\");\n    }\n\n    const adminUserPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n      .from(adminPracticesTable)\n      .where(eq(adminPracticesTable.administratorId, userId));\n    if (!adminUserPractices.map(p => p.practiceId).includes(newPracticeId)) {\n        console.error(`[AuthAction switchPracticeAction] Administrator ${userId} does not have access to practice ${newPracticeId}.`);\n        throw new Error(\"Administrator does not have access to this practice.\");\n    }\n\n    console.log(`[AuthAction switchPracticeAction] Updating currentPracticeId for user ${userId} to ${newPracticeId} in DB.`);\n    await db.update(usersTable)\n      .set({ currentPracticeId: newPracticeId }) // `updatedAt` should be handled by DB/Drizzle automatically\n      .where(eq(usersTable.id, userId));\n    console.log(`[AuthAction switchPracticeAction] DB update successful for user ${userId}.`);\n    \n     const updatedDbUser = await db.select().from(usersTable).where(eq(usersTable.id, userId)).limit(1);\n     if(!updatedDbUser[0]) {\n        console.error(`[AuthAction switchPracticeAction] Failed to refetch user ${userId} after update.`);\n        throw new Error(\"Failed to refetch user after update.\")\n     }\n    console.log(`[AuthAction switchPracticeAction] Refetched user ${userId}, currentPracticeId from DB: ${updatedDbUser[0].currentPracticeId}`);\n\n    const adminPractices = await db.select({ practiceId: adminPracticesTable.practiceId })\n      .from(adminPracticesTable)\n      .where(eq(adminPracticesTable.administratorId, updatedDbUser[0].id));\n    const accessiblePracticeIds = adminPractices.map(p => p.practiceId);\n\n    const refreshedUser: AdministratorUser = { \n        id: updatedDbUser[0].id,\n        email: updatedDbUser[0].email,\n        name: updatedDbUser[0].name || undefined,\n        role: 'ADMINISTRATOR',\n        accessiblePracticeIds: accessiblePracticeIds,\n        currentPracticeId: newPracticeId, // Explicitly use newPracticeId that was set\n    }\n    console.log(`[AuthAction switchPracticeAction] Successfully switched practice for user ${userId}. Refreshed user currentPracticeId: ${refreshedUser.currentPracticeId}`);\n    return { success: true, updatedUser: refreshedUser };\n\n  } catch (error) {\n    console.error(\"[AuthAction switchPracticeAction] Failed to switch practice:\", error instanceof Error ? error.message : error);\n    if (error instanceof Error) {\n        return { success: false, updatedUser: undefined }; \n    }\n    return { success: false };\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 674, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/config/authConstants.ts"],"sourcesContent":["\nexport const SESSION_TOKEN_COOKIE_NAME = 'smartdvm-user-session'; // Client-readable cookie with user object\nexport const HTTP_ONLY_SESSION_TOKEN_COOKIE_NAME = 'session_token'; // Server-set HttpOnly cookie (session ID)\nexport const SESSION_MAX_AGE_SECONDS = 60 * 60 * 24 * 7; // 7 days in seconds\n"],"names":[],"mappings":";;;;;AACO,MAAM,4BAA4B,yBAAyB,0CAA0C;AACrG,MAAM,sCAAsC,iBAAiB,0CAA0C;AACvG,MAAM,0BAA0B,KAAK,KAAK,KAAK,GAAG,oBAAoB","debugId":null}},
    {"offset": {"line": 688, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/api/auth/login/route.ts"],"sourcesContent":["\n// src/app/api/auth/login/route.ts\nimport { NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport { db } from '@/db';\nimport { sessions as sessionsTable } from '@/db/schema';\nimport { cookies } from 'next/headers';\nimport { loginUserAction } from '@/actions/authActions';\nimport type { User } from '@/context/UserContext';\nimport { HTTP_ONLY_SESSION_TOKEN_COOKIE_NAME, SESSION_MAX_AGE_SECONDS } from '@/config/authConstants';\n\nconst SignInSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address.' }),\n  password: z.string().min(1, { message: 'Password is required.' }),\n});\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const validationResult = SignInSchema.safeParse(body);\n\n    if (!validationResult.success) {\n      return NextResponse.json({ error: validationResult.error.errors.map(e => e.message).join(', ') }, { status: 400 });\n    }\n\n    const { email, password: inputPassword } = validationResult.data;\n\n    // Call the server action for the core logic\n    // This action will throw an error if login fails (user not found, wrong password, practice association issue)\n    const userData = await loginUserAction(email, inputPassword);\n\n    // If loginUserAction is successful, userData is populated.\n    // Session management\n    const sessionTokenValue = crypto.randomUUID(); // This is the session ID for DB\n    const sessionExpiresAtDate = new Date(Date.now() + SESSION_MAX_AGE_SECONDS * 1000);\n    const isSqlite = process.env.DB_TYPE === 'sqlite';\n\n    await db.insert(sessionsTable).values({\n      id: sessionTokenValue,\n      userId: userData.id,\n      expiresAt: isSqlite ? sessionExpiresAtDate.getTime() : sessionExpiresAtDate,\n      // data: null, // 'data' column can be used to store additional session info if needed\n      // createdAt will be handled by DB default\n    });\n\n    cookies().set(HTTP_ONLY_SESSION_TOKEN_COOKIE_NAME, sessionTokenValue, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      maxAge: SESSION_MAX_AGE_SECONDS,\n      path: '/',\n      sameSite: 'lax',\n      expires: sessionExpiresAtDate,\n    });\n\n    // Return the full user object to the client\n    return NextResponse.json({ user: userData, message: 'Signed in successfully!' });\n\n  } catch (error) {\n    console.error('API login error details:');\n    if (error instanceof Error) {\n        console.error('Error Name:', error.name);\n        console.error('Error Message:', error.message);\n        console.error('Error Stack:', error.stack);\n    } else {\n        console.error('Caught a non-Error object:', error);\n    }\n\n    // Check for specific error messages from loginUserAction\n    if (error instanceof Error && \n        (error.message.includes('User not found') || \n         error.message.includes('Invalid credentials') || \n         error.message.includes('not associated with a practice') ||\n         error.message.includes('Unknown user role'))) {\n      return NextResponse.json({ error: error.message }, { status: 401 });\n    }\n    \n    // Log that we are falling through to the generic error\n    console.error('API login error is not a specific known auth error. Returning generic 500.');\n    return NextResponse.json({ error: 'An unexpected error occurred. Please try again.' }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"AACA,kCAAkC;;;;AAClC;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;;;;;;;;;;;;;AAEA,MAAM,eAAe,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC5B,OAAO,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,KAAK,CAAC;QAAE,SAAS;IAAyB;IAC5D,UAAU,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAwB;AACjE;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,mBAAmB,aAAa,SAAS,CAAC;QAEhD,IAAI,CAAC,iBAAiB,OAAO,EAAE;YAC7B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO,iBAAiB,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO,EAAE,IAAI,CAAC;YAAM,GAAG;gBAAE,QAAQ;YAAI;QAClH;QAEA,MAAM,EAAE,KAAK,EAAE,UAAU,aAAa,EAAE,GAAG,iBAAiB,IAAI;QAEhE,4CAA4C;QAC5C,8GAA8G;QAC9G,MAAM,WAAW,MAAM,CAAA,GAAA,+HAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;QAE9C,2DAA2D;QAC3D,qBAAqB;QACrB,MAAM,oBAAoB,OAAO,UAAU,IAAI,gCAAgC;QAC/E,MAAM,uBAAuB,IAAI,KAAK,KAAK,GAAG,KAAK,gIAAA,CAAA,0BAAuB,GAAG;QAC7E,MAAM,WAAW,QAAQ,GAAG,CAAC,OAAO,KAAK;QAEzC,MAAM,oHAAA,CAAA,KAAE,CAAC,MAAM,CAAC,wIAAA,CAAA,WAAa,EAAE,MAAM,CAAC;YACpC,IAAI;YACJ,QAAQ,SAAS,EAAE;YACnB,WAAW,WAAW,qBAAqB,OAAO,KAAK;QAGzD;QAEA,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,gIAAA,CAAA,sCAAmC,EAAE,mBAAmB;YACpE,UAAU;YACV,QAAQ,oDAAyB;YACjC,QAAQ,gIAAA,CAAA,0BAAuB;YAC/B,MAAM;YACN,UAAU;YACV,SAAS;QACX;QAEA,4CAA4C;QAC5C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,MAAM;YAAU,SAAS;QAA0B;IAEhF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC;QACd,IAAI,iBAAiB,OAAO;YACxB,QAAQ,KAAK,CAAC,eAAe,MAAM,IAAI;YACvC,QAAQ,KAAK,CAAC,kBAAkB,MAAM,OAAO;YAC7C,QAAQ,KAAK,CAAC,gBAAgB,MAAM,KAAK;QAC7C,OAAO;YACH,QAAQ,KAAK,CAAC,8BAA8B;QAChD;QAEA,yDAAyD;QACzD,IAAI,iBAAiB,SACjB,CAAC,MAAM,OAAO,CAAC,QAAQ,CAAC,qBACvB,MAAM,OAAO,CAAC,QAAQ,CAAC,0BACvB,MAAM,OAAO,CAAC,QAAQ,CAAC,qCACvB,MAAM,OAAO,CAAC,QAAQ,CAAC,oBAAoB,GAAG;YACjD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO,MAAM,OAAO;YAAC,GAAG;gBAAE,QAAQ;YAAI;QACnE;QAEA,uDAAuD;QACvD,QAAQ,KAAK,CAAC;QACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAkD,GAAG;YAAE,QAAQ;QAAI;IACvG;AACF","debugId":null}}]
}